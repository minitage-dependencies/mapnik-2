diff -Nur v2.1.0/mapnik-mapnik-ef297c6/2.1.x.patch upstream/mapnik-mapnik-ef297c6/2.1.x.patch
--- v2.1.0/mapnik-mapnik-ef297c6/2.1.x.patch	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/2.1.x.patch	2013-06-01 19:43:08.037083442 +0200
@@ -0,0 +1,2471 @@
+diff --git a/CHANGELOG.md b/CHANGELOG.md
+index a1a3e41..09a0f87 100644
+--- a/CHANGELOG.md
++++ b/CHANGELOG.md
+@@ -7,6 +7,17 @@ Developers: Please commit along with changes.
+ For a complete change history, see the git log.
+ 
+ 
++## Unreleased
++
++- Added serialization of `line-offset` to save_map (#1562)
++
++- Added support for controlling rendering behavior of markers on multi-geometries `marker-multi-policy` (#1555,#1573)
++
++- Add DebugSymbolizer (#1366)
++
++- Added support for literal types in PostGIS Plugin (#1464)
++
++
+ ## Mapnik 2.1.0
+ 
+ Released Aug 23, 2012
+diff --git a/Makefile b/Makefile
+index 58b999a..0f400ce 100755
+--- a/Makefile
++++ b/Makefile
+@@ -25,7 +25,7 @@ test:
+ 	@python tests/visual_tests/test.py -q || true
+ 	@echo "*** Running C++ tests..."
+ 	@for FILE in tests/cpp_tests/*-bin; do \
+-		$${FILE}; \
++		$${FILE} || exit 1;\
+ 	done
+ 	@echo "*** Running python tests..."
+ 	@python tests/run_tests.py -q
+diff --git a/SConstruct b/SConstruct
+index cc60e71..11bd31f 100644
+--- a/SConstruct
++++ b/SConstruct
+@@ -350,7 +350,7 @@ opts.AddVariables(
+ 
+     # Other variables
+     BoolVariable('SHAPE_MEMORY_MAPPED_FILE', 'Utilize memory-mapped files in Shapefile Plugin (higher memory usage, better performance)', 'True'),
+-    ('SYSTEM_FONTS','Provide location for python bindings to register fonts (if given aborts installation of bundled DejaVu fonts)',''),
++    ('SYSTEM_FONTS','Provide location for python bindings to register fonts (if provided then the bundled DejaVu fonts are not installed)',''),
+     ('LIB_DIR_NAME','Name to use for the subfolder beside libmapnik where fonts and plugins are installed','mapnik'),
+     PathVariable('PYTHON','Full path to Python executable used to build bindings', sys.executable),
+     BoolVariable('FRAMEWORK_PYTHON', 'Link against Framework Python on Mac OS X', 'True'),
+@@ -962,6 +962,7 @@ if not preconfigured:
+     env['PLUGINS'] = PLUGINS
+     env['EXTRA_FREETYPE_LIBS'] = []
+     env['SQLITE_LINKFLAGS'] = []
++    env['PYTHON_INCLUDES'] = []
+     # previously a leading / was expected for LIB_DIR_NAME
+     # now strip it to ensure expected behavior
+     if env['LIB_DIR_NAME'].startswith(os.path.sep):
+@@ -1355,7 +1356,14 @@ if not preconfigured:
+                 py_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print(get_python_inc())"''' % env['PYTHON']
+             else:
+                 py_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print get_python_inc()"''' % env['PYTHON']
+-            env['PYTHON_INCLUDES'] = call(py_includes)
++            env['PYTHON_INCLUDES'].append(call(py_includes))
++
++            # also append platform specific includes
++            if py3:
++                py_plat_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print(get_python_inc(plat_specific=True))"''' % env['PYTHON']
++            else:
++                py_plat_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print get_python_inc(plat_specific=True)"''' % env['PYTHON']
++            env['PYTHON_INCLUDES'].append(call(py_plat_includes))
+ 
+             # Note: we use the plat_specific argument here to make sure to respect the arch-specific site-packages location
+             if py3:
+@@ -1366,7 +1374,7 @@ if not preconfigured:
+         else:
+             env['PYTHON_SYS_PREFIX'] = os.popen('''%s -c "import sys; print sys.prefix"''' % env['PYTHON']).read().strip()
+             env['PYTHON_VERSION'] = os.popen('''%s -c "import sys; print sys.version"''' % env['PYTHON']).read()[0:3]
+-            env['PYTHON_INCLUDES'] = env['PYTHON_SYS_PREFIX'] + '/include/python' + env['PYTHON_VERSION']
++            env['PYTHON_INCLUDES'] = [env['PYTHON_SYS_PREFIX'] + '/include/python' + env['PYTHON_VERSION']]
+             env['PYTHON_SITE_PACKAGES'] = env['DESTDIR'] + os.path.sep + env['PYTHON_SYS_PREFIX'] + os.path.sep + env['LIBDIR_SCHEMA'] + '/python' + env['PYTHON_VERSION'] + '/site-packages/'
+ 
+         # if user-requested custom prefix fall back to manual concatenation for building subdirectories
+@@ -1444,7 +1452,7 @@ if not preconfigured:
+         # fetch the mapnik version header in order to set the
+         # ABI version used to build libmapnik.so on linux in src/build.py
+         abi = conf.GetMapnikLibVersion()
+-        abi_fallback = "2.1.0"
++        abi_fallback = "2.1.1-pre"
+         if not abi:
+             color_print(1,'Problem encountered parsing mapnik version, falling back to %s' % abi_fallback)
+             abi = abi_fallback
+@@ -1532,7 +1540,8 @@ if not preconfigured:
+             # as they are later set in the python build.py
+             # ugly hack needed until we have env specific conf
+             backup = env.Clone().Dictionary()
+-            env.AppendUnique(CPPPATH = os.path.realpath(env['PYTHON_INCLUDES']))
++            for pyinc in env['PYTHON_INCLUDES']:
++                env.AppendUnique(CPPPATH = os.path.realpath(pyinc))
+ 
+             if not conf.CheckHeader(header='Python.h',language='C'):
+                 color_print(1,'Could not find required header files for the Python language (version %s)' % env['PYTHON_VERSION'])
+diff --git a/bindings/python/mapnik/__init__.py b/bindings/python/mapnik/__init__.py
+index a89ff22..1b66dd9 100644
+--- a/bindings/python/mapnik/__init__.py
++++ b/bindings/python/mapnik/__init__.py
+@@ -699,6 +699,18 @@ class PythonDatasource(object):
+ 
+ class _TextSymbolizer(TextSymbolizer,_injector):
+     @property
++    def name(self):
++        if isinstance(self.properties.format_tree, FormattingText):
++            return self.properties.format_tree.text
++        else:
++            # There is no single expression which could be returned as name
++            raise RuntimeError("TextSymbolizer uses complex formatting features, but old compatibility interface is used to access it. Use self.properties.format_tree instead.")
++
++    @name.setter
++    def name(self, name):
++        self.properties.format_tree = FormattingText(name)
++
++    @property
+     def text_size(self):
+         warnings.warn("'text_size' is deprecated, use format.text_size",
+         DeprecationWarning, 2)
+diff --git a/bindings/python/mapnik_fontset.cpp b/bindings/python/mapnik_fontset.cpp
+index f467d81..fbc94a2 100644
+--- a/bindings/python/mapnik_fontset.cpp
++++ b/bindings/python/mapnik_fontset.cpp
+@@ -33,8 +33,13 @@ using mapnik::font_set;
+ void export_fontset ()
+ {
+     using namespace boost::python;
+-    class_<font_set>("FontSet", init<>("default fontset constructor")
++    class_<font_set>("FontSet", init<std::string const&>("default fontset constructor")
+         )
++        .add_property("name",
++                       make_function(&font_set::get_name,return_value_policy<copy_const_reference>()),
++                       &font_set::set_name,
++                      "Get/Set the name of the FontSet.\n"
++            )
+         .def("add_face_name",&font_set::add_face_name,
+              (arg("name")),
+              "Add a face-name to the fontset.\n"
+diff --git a/bindings/python/mapnik_markers_symbolizer.cpp b/bindings/python/mapnik_markers_symbolizer.cpp
+index 0851997..fb0f44d 100644
+--- a/bindings/python/mapnik_markers_symbolizer.cpp
++++ b/bindings/python/mapnik_markers_symbolizer.cpp
+@@ -89,6 +89,12 @@ void export_markers_symbolizer()
+         .value("LINE_PLACEMENT",mapnik::MARKER_LINE_PLACEMENT)
+         ;
+ 
++    mapnik::enumeration_<mapnik::marker_multi_policy_e>("marker_multi_policy")
++        .value("EACH",mapnik::MARKER_EACH_MULTI)
++        .value("WHOLE",mapnik::MARKER_WHOLE_MULTI)
++        .value("LARGEST",mapnik::MARKER_LARGEST_MULTI)
++        ;
++
+     class_<markers_symbolizer>("MarkersSymbolizer",
+                                init<>("Default Markers Symbolizer - circle"))
+         .def (init<mapnik::path_expression_ptr>("<path expression ptr>"))
+@@ -143,6 +149,10 @@ void export_markers_symbolizer()
+                       &markers_symbolizer::get_marker_placement,
+                       &markers_symbolizer::set_marker_placement,
+                       "Set/get the marker placement")
++        .add_property("multi_policy",
++                      &markers_symbolizer::get_marker_multi_policy,
++                      &markers_symbolizer::set_marker_multi_policy,
++                      "Set/get the marker multi geometry rendering policy")
+         .add_property("comp_op",
+                       &markers_symbolizer::comp_op,
+                       &markers_symbolizer::set_comp_op,
+diff --git a/bindings/python/mapnik_python.cpp b/bindings/python/mapnik_python.cpp
+index 705d4fd..bb187fe 100644
+--- a/bindings/python/mapnik_python.cpp
++++ b/bindings/python/mapnik_python.cpp
+@@ -295,6 +295,16 @@ void runtime_error_translator(std::runtime_error const & ex)
+     PyErr_SetString(PyExc_RuntimeError, ex.what());
+ }
+ 
++void out_of_range_error_translator(std::out_of_range const & ex)
++{
++    PyErr_SetString(PyExc_IndexError, ex.what());
++}
++
++void standard_error_translator(std::exception const & ex)
++{
++    PyErr_SetString(PyExc_RuntimeError, ex.what());
++}
++
+ unsigned mapnik_version()
+ {
+     return MAPNIK_VERSION;
+@@ -364,6 +374,8 @@ BOOST_PYTHON_MODULE(_mapnik)
+     using mapnik::save_map_to_string;
+     using mapnik::render_grid;
+ 
++    register_exception_translator<std::exception>(&standard_error_translator);
++    register_exception_translator<std::out_of_range>(&out_of_range_error_translator);
+     register_exception_translator<mapnik::config_error>(&config_error_translator);
+     register_exception_translator<mapnik::value_error>(&value_error_translator);
+     register_exception_translator<std::runtime_error>(&runtime_error_translator);
+@@ -617,6 +629,7 @@ BOOST_PYTHON_MODULE(_mapnik)
+     def("has_pycairo", &has_pycairo, "Get pycairo module status");
+ 
+     python_optional<mapnik::stroke>();
++    python_optional<mapnik::font_set>();
+     python_optional<mapnik::color>();
+     python_optional<mapnik::box2d<double> >();
+     python_optional<mapnik::composite_mode_e>();
+diff --git a/bindings/python/mapnik_query.cpp b/bindings/python/mapnik_query.cpp
+index f0041b8..3c6138a 100644
+--- a/bindings/python/mapnik_query.cpp
++++ b/bindings/python/mapnik_query.cpp
+@@ -22,11 +22,15 @@
+ 
+ // boost
+ #include <boost/python.hpp>
++#include <boost/foreach.hpp>
+ 
+ // mapnik
+ #include <mapnik/query.hpp>
+ #include <mapnik/box2d.hpp>
+ 
++#include <string>
++#include <set>
++
+ using mapnik::query;
+ using mapnik::box2d;
+ 
+@@ -46,11 +50,30 @@ struct resolution_to_tuple
+     }
+ };
+ 
++struct names_to_list
++{
++    static PyObject* convert(std::set<std::string> const& names)
++    {
++        boost::python::list l;
++        BOOST_FOREACH( std::string const& name, names )
++        {
++            l.append(name);
++        }
++        return python::incref(l.ptr());
++    }
++
++    static PyTypeObject const* get_pytype()
++    {
++        return &PyList_Type;
++    }
++};
++
+ void export_query()
+ {
+     using namespace boost::python;
+ 
+     to_python_converter<query::resolution_type, resolution_to_tuple> ();
++    to_python_converter<std::set<std::string>, names_to_list> ();
+ 
+     class_<query>("Query", "a spatial query data object",
+                   init<box2d<double>,query::resolution_type const&,double>() )
+diff --git a/bindings/python/mapnik_text_placement.cpp b/bindings/python/mapnik_text_placement.cpp
+index 29fdad0..f52e2a0 100644
+--- a/bindings/python/mapnik_text_placement.cpp
++++ b/bindings/python/mapnik_text_placement.cpp
+@@ -402,9 +402,9 @@ void export_text_placement()
+     class_with_converter<char_properties>
+         ("CharProperties")
+         .def_readwrite_convert("text_transform", &char_properties::text_transform)
++        .def_readwrite_convert("fontset", &char_properties::fontset)
+         .def(init<char_properties const&>()) //Copy constructor
+         .def_readwrite("face_name", &char_properties::face_name)
+-        .def_readwrite("fontset", &char_properties::fontset)
+         .def_readwrite("text_size", &char_properties::text_size)
+         .def_readwrite("character_spacing", &char_properties::character_spacing)
+         .def_readwrite("line_spacing", &char_properties::line_spacing)
+diff --git a/deps/agg/include/agg_conv_adaptor_vcgen.h b/deps/agg/include/agg_conv_adaptor_vcgen.h
+index a79f220..ddbcef7 100644
+--- a/deps/agg/include/agg_conv_adaptor_vcgen.h
++++ b/deps/agg/include/agg_conv_adaptor_vcgen.h
+@@ -29,6 +29,7 @@ namespace agg
+ 
+         void rewind(unsigned) {}
+         unsigned vertex(double*, double*) { return path_cmd_stop; }
++        unsigned type() const { return 0; }
+     };
+ 
+ 
+@@ -64,6 +65,7 @@ namespace agg
+         }
+ 
+         unsigned vertex(double* x, double* y);
++        unsigned type() const { return m_source->type(); }
+ 
+     private:
+         // Prohibit copying
+diff --git a/deps/agg/include/agg_conv_adaptor_vpgen.h b/deps/agg/include/agg_conv_adaptor_vpgen.h
+index d6b545e..ae8d593 100644
+--- a/deps/agg/include/agg_conv_adaptor_vpgen.h
++++ b/deps/agg/include/agg_conv_adaptor_vpgen.h
+@@ -33,6 +33,7 @@ namespace agg
+ 
+         void rewind(unsigned path_id);
+         unsigned vertex(double* x, double* y);
++        unsigned type() const { return m_source->type(); }
+ 
+     private:
+         conv_adaptor_vpgen(const conv_adaptor_vpgen<VertexSource, VPGen>&);
+diff --git a/deps/agg/include/agg_conv_clip_polygon.h b/deps/agg/include/agg_conv_clip_polygon.h
+index 8753763..79aceed 100644
+--- a/deps/agg/include/agg_conv_clip_polygon.h
++++ b/deps/agg/include/agg_conv_clip_polygon.h
+@@ -51,6 +51,7 @@ namespace agg
+         double y1() const { return base_type::vpgen().y1(); }
+         double x2() const { return base_type::vpgen().x2(); }
+         double y2() const { return base_type::vpgen().y2(); }
++        unsigned type() const { return base_type::type(); }
+ 
+     private:
+         conv_clip_polygon(const conv_clip_polygon<VertexSource>&);
+diff --git a/deps/agg/include/agg_conv_clip_polyline.h b/deps/agg/include/agg_conv_clip_polyline.h
+index f3fc288..8bad596 100644
+--- a/deps/agg/include/agg_conv_clip_polyline.h
++++ b/deps/agg/include/agg_conv_clip_polyline.h
+@@ -51,6 +51,7 @@ namespace agg
+         double y1() const { return base_type::vpgen().y1(); }
+         double x2() const { return base_type::vpgen().x2(); }
+         double y2() const { return base_type::vpgen().y2(); }
++        unsigned type() const { return base_type::type(); }
+ 
+     private:
+         conv_clip_polyline(const conv_clip_polyline<VertexSource>&);
+diff --git a/deps/agg/include/agg_conv_smooth_poly1.h b/deps/agg/include/agg_conv_smooth_poly1.h
+index 4ac4e3d..00ab6b6 100644
+--- a/deps/agg/include/agg_conv_smooth_poly1.h
++++ b/deps/agg/include/agg_conv_smooth_poly1.h
+@@ -42,6 +42,7 @@ namespace agg
+ 
+         void   smooth_value(double v) { base_type::generator().smooth_value(v); }
+         double smooth_value() const { return base_type::generator().smooth_value(); }
++        unsigned type() const { return base_type::type(); }
+ 
+     private:
+         conv_smooth_poly1(const conv_smooth_poly1<VertexSource>&);
+@@ -64,6 +65,7 @@ namespace agg
+ 
+         void   smooth_value(double v) { m_smooth.generator().smooth_value(v); }
+         double smooth_value() const { return m_smooth.generator().smooth_value(); }
++        unsigned type() const { return m_smooth.type(); }
+ 
+     private:
+         conv_smooth_poly1_curve(const conv_smooth_poly1_curve<VertexSource>&);
+diff --git a/fonts/build.py b/fonts/build.py
+index e905293..07e795e 100644
+--- a/fonts/build.py
++++ b/fonts/build.py
+@@ -22,15 +22,12 @@ import glob
+ 
+ Import('env')
+ 
+-# grab all the deja vu fonts
+-includes = glob.glob('*/*/*.ttf')
+-
+-# grab single unifont ttf (available at http://unifoundry.com/unifont.html)
+-includes.extend(glob.glob('unifont*.ttf'))
+-
+-target_path = env['MAPNIK_FONTS_DEST']
+-
+-if 'uninstall' not in COMMAND_LINE_TARGETS and not env['SYSTEM_FONTS']:
+-    env.Alias(target='install', source=env.Install(target_path, includes))
+-
+-env['create_uninstall_target'](env, target_path)
+\ No newline at end of file
++if not env['SYSTEM_FONTS']:
++    # grab all the deja vu fonts
++    includes = glob.glob('*/*/*.ttf')
++    # grab single unifont ttf (available at http://unifoundry.com/unifont.html)
++    includes.extend(glob.glob('unifont*.ttf'))
++    target_path = env['MAPNIK_FONTS_DEST']
++    if 'uninstall' not in COMMAND_LINE_TARGETS:
++        env.Alias(target='install', source=env.Install(target_path, includes))
++    env['create_uninstall_target'](env, target_path)
+diff --git a/include/mapnik/ctrans.hpp b/include/mapnik/ctrans.hpp
+index a56bc4b..07fbc9c 100644
+--- a/include/mapnik/ctrans.hpp
++++ b/include/mapnik/ctrans.hpp
+@@ -81,6 +81,11 @@ struct MAPNIK_DECL coord_transform
+         geom_.rewind(pos);
+     }
+ 
++    unsigned type() const
++    {
++      return static_cast<unsigned>(geom_.type());
++    }
++
+     Geometry const& geom() const
+     {
+         return geom_;
+diff --git a/include/mapnik/font_engine_freetype.hpp b/include/mapnik/font_engine_freetype.hpp
+index 6b77631..048065e 100644
+--- a/include/mapnik/font_engine_freetype.hpp
++++ b/include/mapnik/font_engine_freetype.hpp
+@@ -333,11 +333,11 @@ public:
+         return face_set;
+     }
+ 
+-    face_set_ptr get_face_set(std::string const& name, font_set const& fset)
++    face_set_ptr get_face_set(std::string const& name, boost::optional<font_set> fset)
+     {
+-        if (fset.size() > 0)
++        if (fset && fset->size() > 0)
+         {
+-            return get_face_set(fset);
++            return get_face_set(*fset);
+         }
+         else
+         {
+diff --git a/include/mapnik/font_set.hpp b/include/mapnik/font_set.hpp
+index d74a014..426d60b 100644
+--- a/include/mapnik/font_set.hpp
++++ b/include/mapnik/font_set.hpp
+@@ -35,11 +35,11 @@ namespace mapnik
+ class MAPNIK_DECL font_set
+ {
+ public:
+-    font_set();
+     font_set(std::string const& name);
+     font_set(font_set const& rhs);
+     font_set& operator=(font_set const& rhs);
+     unsigned size() const;
++    void set_name(std::string const& name);
+     std::string const& get_name() const;
+     void add_face_name(std::string);
+     std::vector<std::string> const& get_face_names() const;
+diff --git a/include/mapnik/geom_util.hpp b/include/mapnik/geom_util.hpp
+index 7e90a76..c875d8b 100644
+--- a/include/mapnik/geom_util.hpp
++++ b/include/mapnik/geom_util.hpp
+@@ -329,6 +329,73 @@ bool centroid(PathType & path, double & x, double & y)
+     return true;
+ }
+ 
++// Compute centroid over a set of paths
++template <typename Iter>
++bool centroid_geoms(Iter start, Iter end, double & x, double & y)
++{
++  double x0 = 0.0;
++  double y0 = 0.0;
++  double x1 = 0.0;
++  double y1 = 0.0;
++  double start_x = x0;
++  double start_y = y0;
++
++  double atmp = 0.0;
++  double xtmp = 0.0;
++  double ytmp = 0.0;
++  unsigned count = 0;
++
++  while (start!=end)
++  {
++    typename Iter::value_type & path = *start++;
++    path.rewind(0);
++    unsigned command = path.vertex(&x0, &y0);
++    if (command == SEG_END) continue;
++
++    if ( ! count++ ) {
++      start_x = x0;
++      start_y = y0;
++    }
++
++    while (SEG_END != (command = path.vertex(&x1, &y1)))
++    {
++        double dx0 = x0 - start_x;
++        double dy0 = y0 - start_y;
++        double dx1 = x1 - start_x;
++        double dy1 = y1 - start_y;
++        double ai = dx0 * dy1 - dx1 * dy0;
++        atmp += ai;
++        xtmp += (dx1 + dx0) * ai;
++        ytmp += (dy1 + dy0) * ai;
++        x0 = x1;
++        y0 = y1;
++        ++count;
++    }
++
++  }
++
++  if (count == 0) return false;
++
++  if (count <= 2) {
++      x = (start_x + x0) * 0.5;
++      y = (start_y + y0) * 0.5;
++      return true;
++  }
++
++  if (atmp != 0)
++  {
++      x = (xtmp/(3*atmp)) + start_x;
++      y = (ytmp/(3*atmp)) + start_y;
++  }
++  else
++  {
++      x = x0;
++      y = y0;
++  }
++
++  return true;
++}
++
+ template <typename PathType>
+ bool hit_test(PathType & path, double x, double y, double tol)
+ {
+diff --git a/include/mapnik/grid/grid_marker_helpers.hpp b/include/mapnik/grid/grid_marker_helpers.hpp
+index a77bd75..f5e3629 100644
+--- a/include/mapnik/grid/grid_marker_helpers.hpp
++++ b/include/mapnik/grid/grid_marker_helpers.hpp
+@@ -78,11 +78,17 @@ struct raster_markers_rasterizer_dispatch_grid
+     {
+         marker_placement_e placement_method = sym_.get_marker_placement();
+         box2d<double> bbox_(0,0, src_.width(),src_.height());
+-        if (placement_method != MARKER_LINE_PLACEMENT)
++        if (placement_method != MARKER_LINE_PLACEMENT ||
++            path.type() == Point)
+         {
+             double x = 0;
+             double y = 0;
+-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
++            if (path.type() == LineString)
++            {
++                if (!label::middle_point(path, x, y))
++                    return;
++            }
++            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
+             {
+                 if (!label::interior_position(path, x, y))
+                     return;
+@@ -209,11 +215,17 @@ struct vector_markers_rasterizer_dispatch_grid
+     void add_path(T & path)
+     {
+         marker_placement_e placement_method = sym_.get_marker_placement();
+-        if (placement_method != MARKER_LINE_PLACEMENT)
++        if (placement_method != MARKER_LINE_PLACEMENT ||
++            path.type() == Point)
+         {
+             double x = 0;
+             double y = 0;
+-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
++            if (path.type() == LineString)
++            {
++                if (!label::middle_point(path, x, y))
++                    return;
++            }
++            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
+             {
+                 if (!label::interior_position(path, x, y))
+                     return;
+diff --git a/include/mapnik/image_filter_types.hpp b/include/mapnik/image_filter_types.hpp
+index bb19f53..b5e4466 100644
+--- a/include/mapnik/image_filter_types.hpp
++++ b/include/mapnik/image_filter_types.hpp
+@@ -75,7 +75,7 @@ inline std::ostream& operator<< (std::ostream& os, gray)
+ 
+ inline std::ostream& operator<< (std::ostream& os, agg_stack_blur const& filter)
+ {
+-    os << "agg-stack-blur:" << filter.rx << ',' << filter.ry;
++    os << "agg-stack-blur(" << filter.rx << ',' << filter.ry << ')';
+     return os;
+ }
+ 
+diff --git a/include/mapnik/json/feature_collection_grammar.hpp b/include/mapnik/json/feature_collection_grammar.hpp
+index 54c749d..6012902 100644
+--- a/include/mapnik/json/feature_collection_grammar.hpp
++++ b/include/mapnik/json/feature_collection_grammar.hpp
+@@ -91,7 +91,7 @@ struct feature_collection_grammar :
+             > lit(']')
+             ;
+         
+-        feature = eps[_a = construct<feature_ptr>(new_<feature_impl>(ctx_,generate_id_()))]
++        feature = eps[_a = phoenix::construct<mapnik::feature_ptr>(new_<mapnik::feature_impl>(ctx_,generate_id_()))]
+             >> feature_g(*_a)[push_back(_r1,_a)]
+             ;
+         
+diff --git a/include/mapnik/marker_helpers.hpp b/include/mapnik/marker_helpers.hpp
+index 9677753..7d98615 100644
+--- a/include/mapnik/marker_helpers.hpp
++++ b/include/mapnik/marker_helpers.hpp
+@@ -87,11 +87,17 @@ struct vector_markers_rasterizer_dispatch
+     {
+         marker_placement_e placement_method = sym_.get_marker_placement();
+ 
+-        if (placement_method != MARKER_LINE_PLACEMENT)
++        if (placement_method != MARKER_LINE_PLACEMENT ||
++            path.type() == Point)
+         {
+             double x = 0;
+             double y = 0;
+-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
++            if (path.type() == LineString)
++            {
++                if (!label::middle_point(path, x, y))
++                    return;
++            }
++            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
+             {
+                 if (!label::interior_position(path, x, y))
+                     return;
+@@ -183,11 +189,17 @@ struct raster_markers_rasterizer_dispatch
+         marker_placement_e placement_method = sym_.get_marker_placement();
+         box2d<double> bbox_(0,0, src_.width(),src_.height());
+ 
+-        if (placement_method != MARKER_LINE_PLACEMENT)
++        if (placement_method != MARKER_LINE_PLACEMENT ||
++            path.type() == Point)
+         {
+             double x = 0;
+             double y = 0;
+-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
++            if (path.type() == LineString)
++            {
++                if (!label::middle_point(path, x, y))
++                    return;
++            }
++            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
+             {
+                 if (!label::interior_position(path, x, y))
+                     return;
+@@ -398,6 +410,68 @@ void setup_transform_scaling(agg::trans_affine & tr, box2d<double> const& bbox,
+     }
+ }
+ 
++// Apply markers to a feature with multiple geometries
++template <typename Converter>
++void apply_markers_multi(feature_impl & feature, Converter& converter, markers_symbolizer const& sym)
++{
++  std::size_t geom_count = feature.paths().size();
++  if (geom_count == 1)
++  {
++      converter.apply(feature.paths()[0]);
++  }
++  else if (geom_count > 1)
++  {
++      marker_multi_policy_e multi_policy = sym.get_marker_multi_policy();
++      marker_placement_e placement = sym.get_marker_placement();
++      if (placement == MARKER_POINT_PLACEMENT &&
++           multi_policy == MARKER_WHOLE_MULTI)
++      {
++          double x, y;
++          if (label::centroid_geoms(feature.paths().begin(), feature.paths().end(), x, y))
++          {
++              geometry_type pt(Point);
++              pt.move_to(x, y);
++              // unset any clipping since we're now dealing with a point
++              converter.template unset<clip_poly_tag>();
++              converter.apply(pt);
++          }
++      }
++      else if ((placement == MARKER_POINT_PLACEMENT || placement == MARKER_INTERIOR_PLACEMENT) &&
++                multi_policy == MARKER_LARGEST_MULTI)
++      {
++          // Only apply to path with largest envelope area
++          // TODO: consider using true area for polygon types
++          double maxarea = 0;
++          geometry_type* largest = 0;
++          BOOST_FOREACH(geometry_type & geom, feature.paths())
++          {
++              const box2d<double>& env = geom.envelope();
++              double area = env.width() * env.height();
++              if (area > maxarea)
++              {
++                  maxarea = area;
++                  largest = &geom;
++              }
++          }
++          if (largest)
++          {
++              converter.apply(*largest);
++          }
++      }
++      else
++      {
++          if (multi_policy != MARKER_EACH_MULTI && placement != MARKER_POINT_PLACEMENT)
++          {
++              MAPNIK_LOG_WARN(marker_symbolizer) << "marker_multi_policy != 'each' has no effect with marker_placement != 'point'";
++          }
++          BOOST_FOREACH(geometry_type & path, feature.paths())
++          {
++            converter.apply(path);
++          }
++      }
++  }
++}
++
+ }
+ 
+ #endif //MAPNIK_MARKER_HELPERS_HPP
+diff --git a/include/mapnik/markers_symbolizer.hpp b/include/mapnik/markers_symbolizer.hpp
+index 1dd832d..ddcb6a8 100644
+--- a/include/mapnik/markers_symbolizer.hpp
++++ b/include/mapnik/markers_symbolizer.hpp
+@@ -46,6 +46,15 @@ enum marker_placement_enum {
+ 
+ DEFINE_ENUM( marker_placement_e, marker_placement_enum );
+ 
++enum marker_multi_policy_enum {
++    MARKER_EACH_MULTI, // each component in a multi gets its marker
++    MARKER_WHOLE_MULTI, // consider all components of a multi as a whole
++    MARKER_LARGEST_MULTI, // only the largest component of a multi gets a marker
++    marker_multi_policy_enum_MAX
++};
++
++DEFINE_ENUM( marker_multi_policy_e, marker_multi_policy_enum );
++
+ struct MAPNIK_DECL markers_symbolizer :
+         public symbolizer_with_image, public symbolizer_base
+ {
+@@ -74,6 +83,8 @@ public:
+     boost::optional<stroke> get_stroke() const;
+     void set_marker_placement(marker_placement_e marker_p);
+     marker_placement_e get_marker_placement() const;
++    void set_marker_multi_policy(marker_multi_policy_e marker_p);
++    marker_multi_policy_e get_marker_multi_policy() const;
+ private:
+     expression_ptr width_;
+     expression_ptr height_;
+@@ -86,6 +97,7 @@ private:
+     boost::optional<float> opacity_;
+     boost::optional<stroke> stroke_;
+     marker_placement_e marker_p_;
++    marker_multi_policy_e marker_mp_;
+ };
+ 
+ }
+diff --git a/include/mapnik/stroke.hpp b/include/mapnik/stroke.hpp
+index 2053d25..edf5277 100644
+--- a/include/mapnik/stroke.hpp
++++ b/include/mapnik/stroke.hpp
+@@ -33,9 +33,7 @@
+ 
+ namespace mapnik
+ {
+-using std::pair;
+-using std::vector;
+-typedef vector<pair<double,double> > dash_array;
++typedef std::vector<std::pair<double,double> > dash_array;
+ 
+ // if you add new tokens, don't forget to add them to the corresponding
+ // string array in the cpp file.
+diff --git a/include/mapnik/text_properties.hpp b/include/mapnik/text_properties.hpp
+index 653ff19..652a0f8 100644
+--- a/include/mapnik/text_properties.hpp
++++ b/include/mapnik/text_properties.hpp
+@@ -33,6 +33,7 @@
+ #include <map>
+ 
+ // boost
++#include <boost/optional.hpp>
+ #include <boost/property_tree/ptree.hpp>
+ 
+ namespace mapnik
+@@ -58,7 +59,7 @@ struct char_properties
+     /** Write object to XML ptree. */
+     void to_xml(boost::property_tree::ptree &node, bool explicit_defaults, char_properties const& dfl=char_properties()) const;
+     std::string face_name;
+-    font_set fontset;
++    boost::optional<font_set> fontset;
+     float text_size;
+     double character_spacing;
+     double line_spacing; //Largest total height (fontsize+line_spacing) per line is chosen
+diff --git a/include/mapnik/text_symbolizer.hpp b/include/mapnik/text_symbolizer.hpp
+index 1824f62..8d6e7f5 100644
+--- a/include/mapnik/text_symbolizer.hpp
++++ b/include/mapnik/text_symbolizer.hpp
+@@ -92,7 +92,7 @@ struct MAPNIK_DECL text_symbolizer : public symbolizer_base
+     void set_text_size(float size);
+     std::string const& get_face_name() const func_deprecated;
+     void set_face_name(std::string face_name);
+-    font_set const& get_fontset() const func_deprecated;
++    boost::optional<font_set> const& get_fontset() const func_deprecated;
+     void set_fontset(font_set const& fset);
+     color const& get_fill() const func_deprecated;
+     void set_fill(color const& fill);
+diff --git a/include/mapnik/util/conversions.hpp b/include/mapnik/util/conversions.hpp
+index 3e4193a..726142c 100644
+--- a/include/mapnik/util/conversions.hpp
++++ b/include/mapnik/util/conversions.hpp
+@@ -38,6 +38,7 @@
+ #if BOOST_VERSION >= 104500
+ #include <boost/config/warning_disable.hpp>
+ #include <boost/spirit/include/karma.hpp>
++#include <boost/math/special_functions/trunc.hpp> // trunc to avoid needing C++11
+ #else
+ #include <boost/lexical_cast.hpp>
+ #endif
+@@ -67,8 +68,80 @@ template <typename T>
+ struct double_policy : boost::spirit::karma::real_policies<T>
+ {
+     typedef boost::spirit::karma::real_policies<T> base_type;
+-    static int floatfield(T n) { return base_type::fmtflags::fixed; }
+-    static unsigned precision(T n) { return 16 ;}
++
++    static int floatfield(T n) {
++      using namespace boost::spirit; // for traits
++
++      if (traits::test_zero(n))
++          return base_type::fmtflags::fixed;
++
++      T abs_n = traits::get_absolute_value(n);
++      return (abs_n >= 1e16 || abs_n < 1e-4)
++        ? base_type::fmtflags::scientific : base_type::fmtflags::fixed;
++    }
++
++    static unsigned precision(T n) {
++      if ( n == 0.0 ) return 0;
++      using namespace boost::spirit; // for traits
++      return static_cast<unsigned>(14 - boost::math::trunc(log10(traits::get_absolute_value(n))));
++    }
++
++    template <typename OutputIterator>
++    static bool dot(OutputIterator& sink, T n, unsigned precision) {
++      if (n == 0.0) return true; // avoid trailing zeroes
++      return base_type::dot(sink, n, precision);
++    }
++
++    template <typename OutputIterator>
++    static bool fraction_part (OutputIterator& sink, T n
++      , unsigned precision_, unsigned precision)
++    {
++        // NOTE: copied from karma only to avoid trailing zeroes
++        //       (maybe a bug ?)
++
++        // allow for ADL to find the correct overload for floor and log10
++        using namespace std;
++
++        using namespace boost::spirit; // for traits
++        using namespace boost::spirit::karma; // for char_inserter
++        using namespace boost; // for remove_const
++
++        if ( traits::test_zero(n) ) return true; // this part added to karma
++
++        // The following is equivalent to:
++        //    generate(sink, right_align(precision, '0')[ulong], n);
++        // but it's spelled out to avoid inter-modular dependencies.
++
++        typename remove_const<T>::type digits =
++            (traits::test_zero(n) ? 0 : floor(log10(n))) + 1;
++        bool r = true;
++        for (/**/; r && digits < precision_; digits = digits + 1)
++            r = char_inserter<>::call(sink, '0');
++        if (precision && r)
++            r = int_inserter<10>::call(sink, n);
++        return r;
++    }
++
++    template <typename CharEncoding, typename Tag, typename OutputIterator>
++    static bool exponent (OutputIterator& sink, long n)
++    {
++        // NOTE: copied from karma to force sign in exponent
++        const bool force_sign = true;
++
++        using namespace boost::spirit; // for traits
++        using namespace boost::spirit::karma; // for char_inserter, sign_inserter
++
++        long abs_n = traits::get_absolute_value(n);
++        bool r = char_inserter<CharEncoding, Tag>::call(sink, 'e') &&
++                 sign_inserter::call(sink, traits::test_zero(n)
++                    , traits::test_negative(n), force_sign);
++
++        // the C99 Standard requires at least two digits in the exponent
++        if (r && abs_n < 10)
++            r = char_inserter<CharEncoding, Tag>::call(sink, '0');
++        return r && int_inserter<10>::call(sink, abs_n);
++    }
++
+ };
+ 
+ 
+@@ -77,7 +150,7 @@ template <>
+ inline bool to_string(std::string & str, double value)
+ {
+     namespace karma = boost::spirit::karma;
+-    typedef boost::spirit::karma::real_generator<double, double_policy<double> > double_type;
++    typedef karma::real_generator<double, double_policy<double> > double_type;
+     std::back_insert_iterator<std::string> sink(str);
+     return karma::generate(sink, double_type(), value);
+ }
+diff --git a/include/mapnik/version.hpp b/include/mapnik/version.hpp
+index 9600bf0..8a409d4 100644
+--- a/include/mapnik/version.hpp
++++ b/include/mapnik/version.hpp
+@@ -23,13 +23,13 @@
+ #ifndef MAPNIK_VERSION_HPP
+ #define MAPNIK_VERSION_HPP
+ 
+-#define MAPNIK_VERSION_IS_RELEASE 1
++#define MAPNIK_VERSION_IS_RELEASE 0
+ 
+ #define MAPNIK_MAJOR_VERSION 2
+ #define MAPNIK_MINOR_VERSION 1
+-#define MAPNIK_PATCH_VERSION 0
++#define MAPNIK_PATCH_VERSION 1
+ 
+-// translates to 200100
++// translates to 200101
+ #define MAPNIK_VERSION (MAPNIK_MAJOR_VERSION*100000) + (MAPNIK_MINOR_VERSION*100) + (MAPNIK_PATCH_VERSION)
+ 
+ #ifndef MAPNIK_STRINGIFY
+diff --git a/include/mapnik/vertex_converters.hpp b/include/mapnik/vertex_converters.hpp
+index ed57a5a..3849806 100644
+--- a/include/mapnik/vertex_converters.hpp
++++ b/include/mapnik/vertex_converters.hpp
+@@ -347,6 +347,16 @@ struct vertex_converter : private boost::noncopyable
+             disp_.vec_[index]=1;
+     }
+ 
++    template <typename Conv>
++    void unset()
++    {
++        typedef typename boost::mpl::find<conv_types,Conv>::type iter;
++        typedef typename boost::mpl::end<conv_types>::type end;
++        std::size_t index = boost::mpl::distance<iter,end>::value - 1;
++        if (index < disp_.vec_.size())
++            disp_.vec_[index]=0;
++    }
++
+ 
+     detail::dispatcher<args_type,conv_types> disp_;
+ };
+diff --git a/plugins/input/postgis/connection.hpp b/plugins/input/postgis/connection.hpp
+index 5f8bf34..6f0a6ad 100644
+--- a/plugins/input/postgis/connection.hpp
++++ b/plugins/input/postgis/connection.hpp
+@@ -53,7 +53,7 @@ public:
+         {
+             std::ostringstream s;
+             s << "Postgis Plugin: ";
+-            if (conn_ )
++            if (conn_)
+             {
+                 std::string msg = PQerrorMessage(conn_);
+                 if (! msg.empty())
+@@ -64,13 +64,13 @@ public:
+                 {
+                     s << "unable to connect to postgres server";
+                 }
++                PQfinish(conn_);
+             }
+             else
+             {
+                 s << "unable to connect to postgres server";
+             }
+             s << "\n" << connection_str;
+-
+             throw mapnik::datasource_exception(s.str());
+         }
+     }
+@@ -152,7 +152,7 @@ public:
+ 
+     bool isOK() const
+     {
+-        return (PQstatus(conn_) != CONNECTION_BAD);
++        return (!closed_) && (PQstatus(conn_) != CONNECTION_BAD);
+     }
+ 
+     void close()
+diff --git a/plugins/input/postgis/postgis_datasource.cpp b/plugins/input/postgis/postgis_datasource.cpp
+index 3f95865..307bdb5 100644
+--- a/plugins/input/postgis/postgis_datasource.cpp
++++ b/plugins/input/postgis/postgis_datasource.cpp
+@@ -127,11 +127,12 @@ void postgis_datasource::bind() const
+     if (pool)
+     {
+         shared_ptr<Connection> conn = pool->borrowObject();
+-        if (conn && conn->isOK())
+-        {
+-            PoolGuard<shared_ptr<Connection>,
+-                shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
++        if (!conn) return;
+ 
++        PoolGuard<shared_ptr<Connection>,
++                  shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
++        if (conn->isOK())
++        {
+             desc_.set_encoding(conn->client_encoding());
+ 
+             if (geometry_table_.empty())
+@@ -391,6 +392,7 @@ void postgis_datasource::bind() const
+                     case 1042:  // bpchar
+                     case 1043:  // varchar
+                     case 25:    // text
++                    case 705:   // literal
+                         desc_.add_descriptor(attribute_descriptor(fld_name, mapnik::String));
+                         break;
+                     default: // should not get here
+@@ -434,6 +436,7 @@ postgis_datasource::~postgis_datasource()
+             if (conn)
+             {
+                 conn->close();
++                pool->returnObject(conn);
+             }
+         }
+     }
+@@ -654,7 +657,10 @@ featureset_ptr postgis_datasource::features(const query& q) const
+             s << "\"" << geometryColumn_ << "\"";
+ 
+             if (simplify_geometries_) {
+-              const double tolerance = std::min(px_gw, px_gh) / 2.0;
++              // 1/20 of pixel seems to be a good compromise to avoid
++              // drop of collapsed polygons.
++              // See https://github.com/mapnik/mapnik/issues/1639
++              const double tolerance = std::min(px_gw, px_gh) / 20.0;
+               s << ", " << tolerance << ")";
+             }
+ 
+@@ -702,7 +708,17 @@ featureset_ptr postgis_datasource::features(const query& q) const
+         }
+         else
+         {
+-            throw mapnik::datasource_exception("Postgis Plugin: bad connection");
++            std::string err_msg = "Postgis Plugin:";
++            if (conn)
++            {
++                err_msg += " Bad connection";
++                pool->returnObject(conn);
++            }
++            else
++            {
++                err_msg += " Null connection";
++            }
++            throw mapnik::datasource_exception(err_msg);
+         }
+     }
+ 
+@@ -725,10 +741,11 @@ featureset_ptr postgis_datasource::features_at_point(coord2d const& pt) const
+     if (pool)
+     {
+         shared_ptr<Connection> conn = pool->borrowObject();
+-        if (conn && conn->isOK())
+-        {
+-            PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
++        if (!conn) return featureset_ptr();
++        PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+ 
++        if (conn->isOK())
++        {
+             if (geometryColumn_.empty())
+             {
+                 std::ostringstream s_error;
+@@ -815,10 +832,10 @@ box2d<double> postgis_datasource::envelope() const
+     if (pool)
+     {
+         shared_ptr<Connection> conn = pool->borrowObject();
+-        if (conn && conn->isOK())
++        if (!conn) return extent_;
++        PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
++        if (conn->isOK())
+         {
+-            PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+-
+             std::ostringstream s;
+ 
+             boost::optional<mapnik::boolean> estimate_extent =
+@@ -916,10 +933,10 @@ boost::optional<mapnik::datasource::geometry_t> postgis_datasource::get_geometry
+     if (pool)
+     {
+         shared_ptr<Connection> conn = pool->borrowObject();
+-        if (conn && conn->isOK())
++        if (!conn) return result;
++        PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
++        if (conn->isOK())
+         {
+-            PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+-
+             std::ostringstream s;
+             std::string g_type;
+ 
+diff --git a/plugins/input/postgis/postgis_featureset.cpp b/plugins/input/postgis/postgis_featureset.cpp
+index dd121a3..746fd2c 100644
+--- a/plugins/input/postgis/postgis_featureset.cpp
++++ b/plugins/input/postgis/postgis_featureset.cpp
+@@ -174,6 +174,7 @@ feature_ptr postgis_featureset::next()
+ 
+                     case 25:   //text
+                     case 1043: //varchar
++                    case 705: //literal
+                     {
+                         feature->put(name, tr_->transcode(buf));
+                         break;
+diff --git a/plugins/input/python/build.py b/plugins/input/python/build.py
+index ded50c9..b3580d3 100644
+--- a/plugins/input/python/build.py
++++ b/plugins/input/python/build.py
+@@ -14,7 +14,8 @@ plugin_env = plugin_base.Clone()
+ plugin_sources = Split(
+   """
+   %(PLUGIN_NAME)s_datasource.cpp
+-  %(PLUGIN_NAME)s_featureset.cpp      
++  %(PLUGIN_NAME)s_featureset.cpp
++  %(PLUGIN_NAME)s_utils.cpp
+   """ % locals()
+         )
+ 
+@@ -25,12 +26,7 @@ libraries = ['mapnik',env['BOOST_PYTHON_LIB'],boost_system,env['ICU_LIB_NAME']]
+ # python plugin is used by a app in python using mapnik's python bindings
+ # we explicitly link to libpython here so that this plugin
+ # can be used from a pure C++ calling application or a different binding language
+-python_link_flag = '-lpython%s' % env['PYTHON_VERSION']
+-
+-if env['PLATFORM'] == 'Darwin':
+-    if env['PYTHON_DYNAMIC_LOOKUP']:
+-        python_link_flag = '-undefined dynamic_lookup'
+-    elif env['FRAMEWORK_PYTHON']:
++if env['PLATFORM'] == 'Darwin' and env['FRAMEWORK_PYTHON']:
+         if env['FRAMEWORK_SEARCH_PATH']:
+             python_link_flag = '-F%s -framework Python -Z' % env['FRAMEWORK_SEARCH_PATH']
+         else:
+@@ -41,6 +37,11 @@ if env['PLATFORM'] == 'Darwin':
+                 python_link_flag = '-F/System/Library/Frameworks/ -framework Python -Z'
+             else:
+                 python_link_flag = '-F/ -framework Python'
++else:
++    # on linux the linkflags end up to early in the compile flags to work correctly
++    python_link_flag = ''
++    # so instead add to libraries
++    libraries.append('python%s' % env['PYTHON_VERSION'])
+ 
+ if env['CUSTOM_LDFLAGS']:
+     linkflags = '%s %s' % (env['CUSTOM_LDFLAGS'], python_link_flag)
+diff --git a/plugins/input/python/python_datasource.cpp b/plugins/input/python/python_datasource.cpp
+index 8f5c48e..4bb29cd 100644
+--- a/plugins/input/python/python_datasource.cpp
++++ b/plugins/input/python/python_datasource.cpp
+@@ -62,147 +62,170 @@ mapnik::layer_descriptor python_datasource::get_descriptor() const
+ void python_datasource::bind() const
+ {
+     using namespace boost;
+-    using namespace boost::python;
+ 
+     if (is_bound_) return;
+ 
+     // if no factory callable is defined, bind is a nop
+     if (factory_.empty()) return;
+ 
+-    // split factory at ':' to parse out module and callable
+-    std::vector<std::string> factory_split;
+-    split(factory_split, factory_, is_any_of(":"));
+-    if ((factory_split.size() < 1) || (factory_split.size() > 2))
+-    {
+-        // FIMXE: is this appropriate error reporting?
+-        std::cerr << "python: factory string must be of the form '[module:]callable' when parsing \""
+-                  << factory_ << '"' << std::endl;
+-        return;
+-    }
+-
+-    // extract the module and the callable
+-    str module_name("__main__"), callable_name;
+-    if (factory_split.size() == 1)
+-    {
+-        callable_name = str(factory_split[0]);
+-    }
+-    else
+-    {
+-        module_name = str(factory_split[0]);
+-        callable_name = str(factory_split[1]);
+-    }
+-
++    try
+     {
++        // split factory at ':' to parse out module and callable
++        std::vector<std::string> factory_split;
++        split(factory_split, factory_, is_any_of(":"));
++        if ((factory_split.size() < 1) || (factory_split.size() > 2))
++        {
++            throw mapnik::datasource_exception(
++                std::string("python: factory string must be of the form '[module:]callable' when parsing \"")
++                      + factory_ + '"');
++        }
++        // extract the module and the callable
++        boost::python::str module_name("__main__"), callable_name;
++        if (factory_split.size() == 1)
++        {
++            callable_name = boost::python::str(factory_split[0]);
++        }
++        else
++        {
++            module_name = boost::python::str(factory_split[0]);
++            callable_name = boost::python::str(factory_split[1]);
++        }
+         ensure_gil lock;
+-
+         // import the main module from Python (in case we're embedding the
+         // interpreter directly) and also import the callable.
+-        object main_module = import("__main__");
+-        object callable_module = import(module_name);
+-        object callable = callable_module.attr(callable_name);
+-
++        boost::python::object main_module = boost::python::import("__main__");
++        boost::python::object callable_module = boost::python::import(module_name);
++        boost::python::object callable = callable_module.attr(callable_name);
+         // prepare the arguments
+-        dict kwargs;
++        boost::python::dict kwargs;
+         typedef std::map<std::string, std::string>::value_type kv_type;
+         BOOST_FOREACH(const kv_type& kv, kwargs_)
+         {
+-            kwargs[str(kv.first)] = str(kv.second);
++            kwargs[boost::python::str(kv.first)] = boost::python::str(kv.second);
+         }
+ 
+         // get our wrapped data source
+         datasource_ = callable(*boost::python::make_tuple(), **kwargs);
+     }
++    catch ( boost::python::error_already_set )
++    {
++        throw mapnik::datasource_exception(extractException());
++    }
+ 
+     is_bound_ = true;
+ }
+ 
+ mapnik::datasource::datasource_t python_datasource::type() const
+ {
+-    using namespace boost::python;
+-
+     typedef boost::optional<mapnik::datasource::geometry_t> return_type;
+ 
+     if (!is_bound_) bind();
+ 
+-    ensure_gil lock;
++    try
++    {
++        ensure_gil lock;
++        boost::python::object data_type = datasource_.attr("data_type");
++        long data_type_integer = boost::python::extract<long>(data_type);
++        return mapnik::datasource::datasource_t(data_type_integer);
++    }
++    catch ( boost::python::error_already_set )
++    {
++        throw mapnik::datasource_exception(extractException());
++    }
+ 
+-    object data_type = datasource_.attr("data_type");
+-    long data_type_integer = extract<long>(data_type);
+-    return mapnik::datasource::datasource_t(data_type_integer);
+ }
+ 
+ mapnik::box2d<double> python_datasource::envelope() const
+ {
+-    using namespace boost::python;
+-
+     if (!is_bound_) bind();
+ 
+-    ensure_gil lock;
+-    return extract<mapnik::box2d<double> >(datasource_.attr("envelope"));
++    try
++    {
++        ensure_gil lock;
++        return boost::python::extract<mapnik::box2d<double> >(datasource_.attr("envelope"));
++    }
++    catch ( boost::python::error_already_set )
++    {
++        throw mapnik::datasource_exception(extractException());
++    }
+ }
+ 
+ boost::optional<mapnik::datasource::geometry_t> python_datasource::get_geometry_type() const
+ {
+-    using namespace boost::python;
+-
+     typedef boost::optional<mapnik::datasource::geometry_t> return_type;
+ 
+     if (!is_bound_) bind();
+ 
+-    ensure_gil lock;
+-
+-    // if the datasource object has no geometry_type attribute, return a 'none' value
+-    if (!PyObject_HasAttrString(datasource_.ptr(), "geometry_type"))
+-        return return_type();
+-
+-    object py_geometry_type = datasource_.attr("geometry_type");
+-
+-    // if the attribute value is 'None', return a 'none' value
+-    if (py_geometry_type.ptr() == object().ptr())
+-        return return_type();
+-
+-    long geom_type_integer = extract<long>(py_geometry_type);
+-    return mapnik::datasource::geometry_t(geom_type_integer);
++    try
++    {
++        ensure_gil lock;
++        // if the datasource object has no geometry_type attribute, return a 'none' value
++        if (!PyObject_HasAttrString(datasource_.ptr(), "geometry_type"))
++        {
++            return return_type();
++        }
++        boost::python::object py_geometry_type = datasource_.attr("geometry_type");
++        // if the attribute value is 'None', return a 'none' value
++        if (py_geometry_type.ptr() == boost::python::object().ptr())
++        {
++            return return_type();
++        }
++        long geom_type_integer = boost::python::extract<long>(py_geometry_type);
++        return mapnik::datasource::geometry_t(geom_type_integer);
++    }
++    catch ( boost::python::error_already_set )
++    {
++        throw mapnik::datasource_exception(extractException());
++    }
+ }
+ 
+ mapnik::featureset_ptr python_datasource::features(mapnik::query const& q) const
+ {
+-    using namespace boost::python;
+-
+     if (!is_bound_) bind();
+ 
+-    // if the query box intersects our world extent then query for features
+-    if (envelope().intersects(q.get_bbox()))
++    try
+     {
+-        ensure_gil lock;
+-
+-        object features(datasource_.attr("features")(q));
+-
+-        // if 'None' was returned, return an empty feature set
+-        if(features.ptr() == object().ptr())
+-            return mapnik::featureset_ptr();
+-
+-        return boost::make_shared<python_featureset>(features);
++        // if the query box intersects our world extent then query for features
++        if (envelope().intersects(q.get_bbox()))
++        {
++            ensure_gil lock;
++            boost::python::object features(datasource_.attr("features")(q));
++            // if 'None' was returned, return an empty feature set
++            if(features.ptr() == boost::python::object().ptr())
++            {
++                return mapnik::featureset_ptr();
++            }
++            return boost::make_shared<python_featureset>(features);
++        }
++        // otherwise return an empty featureset pointer
++        return mapnik::featureset_ptr();
++    }
++    catch ( boost::python::error_already_set )
++    {
++        throw mapnik::datasource_exception(extractException());
+     }
+-
+-    // otherwise return an empty featureset pointer
+-    return mapnik::featureset_ptr();
+ }
+ 
+ mapnik::featureset_ptr python_datasource::features_at_point(mapnik::coord2d const& pt) const
+ {
+-    using namespace boost::python;
+ 
+     if (!is_bound_) bind();
+ 
+-    ensure_gil lock;
+-
+-    object features(datasource_.attr("features_at_point")(pt));
+-
+-    // if we returned none, return an empty set
+-    if(features.ptr() == object().ptr())
+-        return mapnik::featureset_ptr();
++    try
++    {
++        ensure_gil lock;
++        boost::python::object features(datasource_.attr("features_at_point")(pt));
++        // if we returned none, return an empty set
++        if(features.ptr() == boost::python::object().ptr())
++        {
++            return mapnik::featureset_ptr();
++        }
++        // otherwise, return a feature set which can iterate over the iterator
++        return boost::make_shared<python_featureset>(features);
++    }
++    catch ( boost::python::error_already_set )
++    {
++        throw mapnik::datasource_exception(extractException());
++    }
+ 
+-    // otherwise, return a feature set which can iterate over the iterator
+-    return boost::make_shared<python_featureset>(features);
+-}
++}
+\ No newline at end of file
+diff --git a/plugins/input/python/python_utils.cpp b/plugins/input/python/python_utils.cpp
+new file mode 100644
+index 0000000..159bf70
+--- /dev/null
++++ b/plugins/input/python/python_utils.cpp
+@@ -0,0 +1,23 @@
++#include "python_utils.hpp"
++
++std::string extractException()
++{
++  using namespace boost::python;
++
++  PyObject *exc,*val,*tb;
++  PyErr_Fetch(&exc,&val,&tb);
++  PyErr_NormalizeException(&exc,&val,&tb);
++  handle<> hexc(exc),hval(allow_null(val)),htb(allow_null(tb));
++  if(!hval)
++  {
++    return extract<std::string>(str(hexc));
++  }
++  else
++  {
++    object traceback(import("traceback"));
++    object format_exception(traceback.attr("format_exception"));
++    object formatted_list(format_exception(hexc,hval,htb));
++    object formatted(str("").join(formatted_list));
++    return extract<std::string>(formatted);
++  }
++}
+diff --git a/plugins/input/python/python_utils.hpp b/plugins/input/python/python_utils.hpp
+index 2fbed12..745cc41 100644
+--- a/plugins/input/python/python_utils.hpp
++++ b/plugins/input/python/python_utils.hpp
+@@ -13,4 +13,6 @@ class ensure_gil
+         PyGILState_STATE gil_state_;
+ };
+ 
++std::string extractException();
++
+ #endif // PYTHON_UTILS_HPP
+diff --git a/src/agg/process_markers_symbolizer.cpp b/src/agg/process_markers_symbolizer.cpp
+index 078dfd5..966d81d 100644
+--- a/src/agg/process_markers_symbolizer.cpp
++++ b/src/agg/process_markers_symbolizer.cpp
+@@ -26,6 +26,7 @@
+ #include <mapnik/agg_rasterizer.hpp>
+ 
+ #include <mapnik/debug.hpp>
++#include <mapnik/feature.hpp>
+ #include <mapnik/geom_util.hpp>
+ #include <mapnik/expression_evaluator.hpp>
+ #include <mapnik/vertex_converters.hpp>
+@@ -136,10 +137,7 @@ void agg_renderer<T>::process(markers_symbolizer const& sym,
+                     }
+                     converter.template set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+                 else
+                 {
+@@ -172,10 +170,7 @@ void agg_renderer<T>::process(markers_symbolizer const& sym,
+                     }
+                     converter.template set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+             }
+             else // raster markers
+@@ -207,11 +202,7 @@ void agg_renderer<T>::process(markers_symbolizer const& sym,
+                 }
+                 converter.template set<transform_tag>(); //always transform
+                 if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
+-
+-                BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                {
+-                    converter.apply(geom);
+-                }
++                apply_markers_multi(feature, converter, sym);
+             }
+         }
+     }
+diff --git a/src/cairo_renderer.cpp b/src/cairo_renderer.cpp
+index c44171d..6972c50 100644
+--- a/src/cairo_renderer.cpp
++++ b/src/cairo_renderer.cpp
+@@ -1494,11 +1494,17 @@ struct markers_dispatch
+     {
+         marker_placement_e placement_method = sym_.get_marker_placement();
+ 
+-        if (placement_method != MARKER_LINE_PLACEMENT)
++        if (placement_method != MARKER_LINE_PLACEMENT ||
++            path.type() == Point)
+         {
+             double x = 0;
+             double y = 0;
+-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
++            if (path.type() == LineString)
++            {
++                if (!label::middle_point(path, x, y))
++                    return;
++            }
++            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
+             {
+                 if (!label::interior_position(path, x, y))
+                     return;
+@@ -1577,11 +1583,17 @@ struct markers_dispatch_2
+     {
+         marker_placement_e placement_method = sym_.get_marker_placement();
+ 
+-        if (placement_method != MARKER_LINE_PLACEMENT)
++        if (placement_method != MARKER_LINE_PLACEMENT ||
++            path.type() == Point)
+         {
+             double x = 0;
+             double y = 0;
+-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
++            if (path.type() == LineString)
++            {
++                if (!label::middle_point(path, x, y))
++                    return;
++            }
++            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
+             {
+                 if (!label::interior_position(path, x, y))
+                     return;
+@@ -1706,10 +1718,7 @@ void cairo_renderer_base::process(markers_symbolizer const& sym,
+                     }
+                     converter.set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+                 else
+                 {
+@@ -1734,10 +1743,7 @@ void cairo_renderer_base::process(markers_symbolizer const& sym,
+                     }
+                     converter.set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+             }
+             else // raster markers
+@@ -1767,10 +1773,7 @@ void cairo_renderer_base::process(markers_symbolizer const& sym,
+                     }
+                     converter.set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+             }
+         }
+diff --git a/src/debug.cpp b/src/debug.cpp
+index d468d2e..0ba0fba 100644
+--- a/src/debug.cpp
++++ b/src/debug.cpp
+@@ -60,14 +60,10 @@ logger::severity_type logger::severity_level_ =
+     #if MAPNIK_DEFAULT_LOG_SEVERITY == 0
+         logger::debug
+     #elif MAPNIK_DEFAULT_LOG_SEVERITY == 1
+-        logger::info
+-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 2
+         logger::warn
+-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 3
++    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 2
+         logger::error
+-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 4
+-        logger::fatal
+-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 5
++    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 3
+         logger::none
+     #else
+         #error "Wrong default log severity level specified!"
+diff --git a/src/font_set.cpp b/src/font_set.cpp
+index 10c2094..06daf5b 100644
+--- a/src/font_set.cpp
++++ b/src/font_set.cpp
+@@ -29,8 +29,6 @@
+ 
+ namespace mapnik
+ {
+-font_set::font_set()
+-    : name_("") {}
+ 
+ font_set::font_set(std::string const& name)
+     : name_(name) {}
+@@ -61,6 +59,11 @@ void font_set::add_face_name(std::string face_name)
+     face_names_.push_back(face_name);
+ }
+ 
++void font_set::set_name(std::string const& name)
++{
++    name_ = name;
++}
++
+ std::string const& font_set::get_name() const
+ {
+     return name_;
+diff --git a/src/grid/process_markers_symbolizer.cpp b/src/grid/process_markers_symbolizer.cpp
+index d21a23d..e4325d2 100644
+--- a/src/grid/process_markers_symbolizer.cpp
++++ b/src/grid/process_markers_symbolizer.cpp
+@@ -163,10 +163,7 @@ void grid_renderer<T>::process(markers_symbolizer const& sym,
+                     }
+                     converter.template set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+                 else
+                 {
+@@ -208,10 +205,7 @@ void grid_renderer<T>::process(markers_symbolizer const& sym,
+                     }
+                     converter.template set<transform_tag>(); //always transform
+                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
+-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                    {
+-                        converter.apply(geom);
+-                    }
++                    apply_markers_multi(feature, converter, sym);
+                 }
+             }
+             else // raster markers
+@@ -256,10 +250,7 @@ void grid_renderer<T>::process(markers_symbolizer const& sym,
+                 }
+                 converter.template set<transform_tag>(); //always transform
+                 if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
+-                BOOST_FOREACH(geometry_type & geom, feature.paths())
+-                {
+-                    converter.apply(geom);
+-                }
++                apply_markers_multi(feature, converter, sym);
+             }
+         }
+     }
+diff --git a/src/json/feature_collection_parser.cpp b/src/json/feature_collection_parser.cpp
+index 3faeda7..51ad824 100644
+--- a/src/json/feature_collection_parser.cpp
++++ b/src/json/feature_collection_parser.cpp
+@@ -20,12 +20,17 @@
+  *
+  *****************************************************************************/
+ 
++// TODO https://github.com/mapnik/mapnik/issues/1658
++#include <boost/version.hpp>
++#if BOOST_VERSION >= 105200
++#define BOOST_SPIRIT_USE_PHOENIX_V3
++#endif
++
+ // mapnik
+ #include <mapnik/json/feature_collection_parser.hpp>
+ #include <mapnik/json/feature_collection_grammar.hpp>
+ 
+ // boost
+-#include <boost/version.hpp>
+ #include <boost/spirit/include/qi.hpp>
+ #include <boost/spirit/include/support_multi_pass.hpp>
+ 
+diff --git a/src/load_map.cpp b/src/load_map.cpp
+index d8ec288..788f4f7 100644
+--- a/src/load_map.cpp
++++ b/src/load_map.cpp
+@@ -514,7 +514,7 @@ void map_parser::parse_fontset(Map & map, xml_node const& fset)
+ 
+         // XXX Hack because map object isn't accessible by text_symbolizer
+         // when it's parsed
+-        fontsets_.insert(pair<std::string, font_set>(name, fontset));
++        fontsets_.insert(std::pair<std::string, font_set>(name, fontset));
+     }
+     catch (const config_error & ex)
+     {
+@@ -1027,6 +1027,10 @@ void map_parser::parse_markers_symbolizer(rule & rule, xml_node const& node)
+ 
+         marker_placement_e placement = node.get_attr<marker_placement_e>("placement",sym.get_marker_placement());
+         sym.set_marker_placement(placement);
++
++        marker_multi_policy_e mpolicy = node.get_attr<marker_multi_policy_e>("multi-policy",sym.get_marker_multi_policy());
++        sym.set_marker_multi_policy(mpolicy);
++
+         parse_symbolizer_base(sym, node);
+         rule.append(sym);
+     }
+@@ -1148,7 +1152,7 @@ void map_parser::parse_text_symbolizer(rule & rule, xml_node const& sym)
+             placement_finder->defaults.from_xml(sym, fontsets_);
+         }
+         if (strict_ &&
+-            !placement_finder->defaults.format.fontset.size())
++            !placement_finder->defaults.format.fontset)
+         {
+             ensure_font_face(placement_finder->defaults.format.face_name);
+         }
+@@ -1177,7 +1181,7 @@ void map_parser::parse_shield_symbolizer(rule & rule, xml_node const& sym)
+         }
+         placement_finder->defaults.from_xml(sym, fontsets_);
+         if (strict_ &&
+-            !placement_finder->defaults.format.fontset.size())
++            !placement_finder->defaults.format.fontset)
+         {
+             ensure_font_face(placement_finder->defaults.format.face_name);
+         }
+diff --git a/src/map.cpp b/src/map.cpp
+index cd5ba28..40d0498 100644
+--- a/src/map.cpp
++++ b/src/map.cpp
+@@ -159,6 +159,10 @@ boost::optional<feature_type_style const&> Map::find_style(std::string const& na
+ 
+ bool Map::insert_fontset(std::string const& name, font_set const& fontset)
+ {
++    if (fontset.get_name() != name)
++    {
++        throw mapnik::config_error("Fontset name must match the name used to reference it on the map");
++    }
+     return fontsets_.insert(make_pair(name, fontset)).second;
+ }
+ 
+diff --git a/src/markers_symbolizer.cpp b/src/markers_symbolizer.cpp
+index e992ef5..cf9d47e 100644
+--- a/src/markers_symbolizer.cpp
++++ b/src/markers_symbolizer.cpp
+@@ -37,6 +37,15 @@ static const char * marker_placement_strings[] = {
+ 
+ IMPLEMENT_ENUM( marker_placement_e, marker_placement_strings )
+ 
++static const char * marker_multi_policy_strings[] = {
++    "each",
++    "whole",
++    "largest",
++    ""
++};
++
++IMPLEMENT_ENUM( marker_multi_policy_e, marker_multi_policy_strings )
++
+ markers_symbolizer::markers_symbolizer()
+     : symbolizer_with_image(parse_path("shape://ellipse")),
+       symbolizer_base(),
+@@ -46,7 +55,10 @@ markers_symbolizer::markers_symbolizer()
+       allow_overlap_(false),
+       spacing_(100.0),
+       max_error_(0.2),
+-      marker_p_(MARKER_POINT_PLACEMENT) { }
++      marker_p_(MARKER_POINT_PLACEMENT),
++      // TODO: consider defaulting to MARKER_WHOLE_MULTI,
++      //       for backward compatibility with 2.0.0
++      marker_mp_(MARKER_EACH_MULTI) { }
+ 
+ markers_symbolizer::markers_symbolizer(path_expression_ptr const& filename)
+     : symbolizer_with_image(filename),
+@@ -57,7 +69,10 @@ markers_symbolizer::markers_symbolizer(path_expression_ptr const& filename)
+       allow_overlap_(false),
+       spacing_(100.0),
+       max_error_(0.2),
+-      marker_p_(MARKER_POINT_PLACEMENT) { }
++      marker_p_(MARKER_POINT_PLACEMENT),
++      // TODO: consider defaulting to MARKER_WHOLE_MULTI,
++      //       for backward compatibility with 2.0.0
++      marker_mp_(MARKER_EACH_MULTI) { }
+ 
+ markers_symbolizer::markers_symbolizer(markers_symbolizer const& rhs)
+     : symbolizer_with_image(rhs),
+@@ -71,7 +86,8 @@ markers_symbolizer::markers_symbolizer(markers_symbolizer const& rhs)
+       fill_(rhs.fill_),
+       fill_opacity_(rhs.fill_opacity_),
+       stroke_(rhs.stroke_),
+-      marker_p_(rhs.marker_p_) {}
++      marker_p_(rhs.marker_p_),
++      marker_mp_(rhs.marker_mp_) {}
+ 
+ void markers_symbolizer::set_ignore_placement(bool ignore_placement)
+ {
+@@ -173,4 +189,14 @@ marker_placement_e markers_symbolizer::get_marker_placement() const
+     return marker_p_;
+ }
+ 
++void markers_symbolizer::set_marker_multi_policy(marker_multi_policy_e marker_mp)
++{
++    marker_mp_ = marker_mp;
++}
++
++marker_multi_policy_e markers_symbolizer::get_marker_multi_policy() const
++{
++    return marker_mp_;
++}
++
+ }
+diff --git a/src/processed_text.cpp b/src/processed_text.cpp
+index caaa316..ab27f37 100644
+--- a/src/processed_text.cpp
++++ b/src/processed_text.cpp
+@@ -65,22 +65,22 @@ string_info &processed_text::get_string_info()
+         face_set_ptr faces = font_manager_.get_face_set(p.face_name, p.fontset);
+         if (faces->size() == 0)
+         {
+-            if (!p.fontset.get_name().empty())
++            if (p.fontset && !p.fontset->get_name().empty())
+             {
+-                if (p.fontset.size())
++                if (p.fontset->size())
+                 {
+                     if (!p.face_name.empty())
+                     {
+-                        throw config_error("Unable to find specified font face '" + p.face_name + "' in font set: '" + p.fontset.get_name() + "'");
++                        throw config_error("Unable to find specified font face '" + p.face_name + "' in font set: '" + p.fontset->get_name() + "'");
+                     }
+                     else
+                     {
+-                        throw config_error("No valid font face could be loaded for font set: '" + p.fontset.get_name() + "'");
++                        throw config_error("No valid font face could be loaded for font set: '" + p.fontset->get_name() + "'");
+                     }
+                 }
+                 else
+                 {
+-                    throw config_error("Font set '" + p.fontset.get_name() + "' does not contain any Font face-name entries");           
++                    throw config_error("Font set '" + p.fontset->get_name() + "' does not contain any Font face-name entries");
+                 }
+             }
+             else if (!p.face_name.empty())
+diff --git a/src/save_map.cpp b/src/save_map.cpp
+index dfc163a..cb43c31 100644
+--- a/src/save_map.cpp
++++ b/src/save_map.cpp
+@@ -98,6 +98,10 @@ public:
+         {
+             set_attr( sym_node, "rasterizer", sym.get_rasterizer() );
+         }
++        if ( sym.offset() != dfl.offset() || explicit_defaults_ )
++        {
++            set_attr( sym_node, "offset", sym.offset() );
++        }
+         serialize_symbolizer_base(sym_node, sym);
+     }
+ 
+@@ -311,6 +315,10 @@ public:
+         {
+             set_attr( sym_node, "placement", sym.get_marker_placement() );
+         }
++        if ( sym.get_marker_multi_policy() != dfl.get_marker_multi_policy() || explicit_defaults_ )
++        {
++            set_attr( sym_node, "multi-policy", sym.get_marker_multi_policy() );
++        }
+         if (sym.get_image_transform())
+         {
+             std::string tr_str = sym.get_image_transform_string();
+diff --git a/src/text_properties.cpp b/src/text_properties.cpp
+index 67fb788..cfe9e5e 100644
+--- a/src/text_properties.cpp
++++ b/src/text_properties.cpp
+@@ -293,11 +293,11 @@ void char_properties::from_xml(xml_node const& sym, fontset_map const& fontsets)
+             throw config_error("Unable to find any fontset named '" + *fontset_name_ + "'", sym);
+         }
+     }
+-    if (!face_name.empty() && !fontset.get_name().empty())
++    if (!face_name.empty() && fontset)
+     {
+         throw config_error("Can't have both face-name and fontset-name", sym);
+     }
+-    if (face_name.empty() && fontset.get_name().empty())
++    if (face_name.empty() && !fontset)
+     {
+         throw config_error("Must have face-name or fontset-name", sym);
+     }
+@@ -305,11 +305,9 @@ void char_properties::from_xml(xml_node const& sym, fontset_map const& fontsets)
+ 
+ void char_properties::to_xml(boost::property_tree::ptree &node, bool explicit_defaults, char_properties const &dfl) const
+ {
+-    std::string const& fontset_name = fontset.get_name();
+-    std::string const& dfl_fontset_name = dfl.fontset.get_name();
+-    if (fontset_name != dfl_fontset_name || explicit_defaults)
++    if (fontset)
+     {
+-        set_attr(node, "fontset-name", fontset_name);
++        set_attr(node, "fontset-name", fontset->get_name());
+     }
+ 
+     if (face_name != dfl.face_name || explicit_defaults)
+diff --git a/src/text_symbolizer.cpp b/src/text_symbolizer.cpp
+index fcd4705..9b61b96 100644
+--- a/src/text_symbolizer.cpp
++++ b/src/text_symbolizer.cpp
+@@ -173,7 +173,7 @@ void text_symbolizer::set_fontset(font_set const& fontset)
+     placement_options_->defaults.format.fontset = fontset;
+ }
+ 
+-font_set const& text_symbolizer::get_fontset() const
++boost::optional<font_set> const& text_symbolizer::get_fontset() const
+ {
+     return placement_options_->defaults.format.fontset;
+ }
+diff --git a/src/xml_tree.cpp b/src/xml_tree.cpp
+index 821f92a..647b979 100644
+--- a/src/xml_tree.cpp
++++ b/src/xml_tree.cpp
+@@ -486,6 +486,7 @@ compile_get_attr(std::string);
+ compile_get_attr(filter_mode_e);
+ compile_get_attr(point_placement_e);
+ compile_get_attr(marker_placement_e);
++compile_get_attr(marker_multi_policy_e);
+ compile_get_attr(pattern_alignment_e);
+ compile_get_attr(line_rasterizer_e);
+ compile_get_attr(colorizer_mode);
+diff --git a/tests/cpp_tests/conversions_test.cpp b/tests/cpp_tests/conversions_test.cpp
+new file mode 100644
+index 0000000..5d8aebc
+--- /dev/null
++++ b/tests/cpp_tests/conversions_test.cpp
+@@ -0,0 +1,133 @@
++#include <boost/version.hpp>
++#include <mapnik/util/conversions.hpp>
++#include <boost/detail/lightweight_test.hpp>
++#include <iostream>
++
++int main( int, char*[] )
++{
++    using mapnik::util::to_string;
++
++    try
++    {
++        std::string out;
++    
++        // Test double
++        to_string(out, double(0));
++        BOOST_TEST_EQ( out,  "0" );
++        out.clear();
++    
++        to_string(out, double(1));
++        BOOST_TEST_EQ( out,  "1" );
++        out.clear();
++    
++        to_string(out, double(-1));
++        BOOST_TEST_EQ( out,  "-1" );
++        out.clear();
++    
++        to_string(out, double(0.1));
++        BOOST_TEST_EQ( out,  "0.1" );
++        out.clear();
++    
++        to_string(out, double(-0.1));
++        BOOST_TEST_EQ( out,  "-0.1" );
++        out.clear();
++    
++        to_string(out, double(0.123));
++        BOOST_TEST_EQ( out,  "0.123" );
++        out.clear();
++    
++        to_string(out, double(-0.123));
++        BOOST_TEST_EQ( out,  "-0.123" );
++        out.clear();
++    
++        to_string(out, double(1e-06));
++        BOOST_TEST_EQ( out,  "1e-06" );
++        out.clear();
++    
++        to_string(out, double(-1e-06));
++        BOOST_TEST_EQ( out,  "-1e-06" );
++        out.clear();
++    
++        to_string(out, double(1e-05));
++        BOOST_TEST_EQ( out,  "1e-05" );
++        out.clear();
++    
++        to_string(out, double(-1e-05));
++        BOOST_TEST_EQ( out,  "-1e-05" );
++        out.clear();
++    
++        to_string(out, double(0.0001));
++        BOOST_TEST_EQ( out,  "0.0001" );
++        out.clear();
++    
++        to_string(out, double(-0.0001));
++        BOOST_TEST_EQ( out,  "-0.0001" );
++        out.clear();
++    
++        to_string(out, double(0.0001234567890123456));
++        // TODO: https://github.com/mapnik/mapnik/issues/1676
++        //BOOST_TEST_EQ( out,  "0.0001234567890123456" );
++        out.clear();
++    
++        to_string(out, double(-0.0001234567890123456));
++        // TODO: https://github.com/mapnik/mapnik/issues/1676
++        //BOOST_TEST_EQ( out,  "-0.0001234567890123456" );
++        out.clear();
++    
++        to_string(out, double(1000000000000000));
++        BOOST_TEST_EQ( out,  "1000000000000000" );
++        out.clear();
++    
++        to_string(out, double(-1000000000000000));
++        BOOST_TEST_EQ( out,  "-1000000000000000" );
++        out.clear();
++    
++        to_string(out, double(10000000000000.1));
++        BOOST_TEST_EQ( out,  "10000000000000.1" );
++        out.clear();
++    
++        to_string(out, double(1.00001));
++        BOOST_TEST_EQ( out,  "1.00001" );
++        out.clear();
++
++        to_string(out, double(67.65));
++        BOOST_TEST_EQ( out,  "67.65" );
++        out.clear();
++
++        to_string(out, double(67.35));
++        BOOST_TEST_EQ( out,  "67.35" );
++        out.clear();
++
++        to_string(out, double(1234000000000000));
++        BOOST_TEST_EQ( out,  "1234000000000000" );
++        out.clear();
++    
++        to_string(out, double(1.234e+16));
++        BOOST_TEST_EQ( out,  "1.234e+16" );
++        out.clear();
++    
++        to_string(out, double(-1.234e+16));
++        BOOST_TEST_EQ( out,  "-1.234e+16" );
++        out.clear();
++    
++        // Test int
++    
++        to_string(out,   int(2));
++        BOOST_TEST_EQ( out, "2" );
++        out.clear();
++    }
++    catch (std::exception const & ex)
++    {
++        std::clog << "C++ type conversions problem: " << ex.what() << "\n";
++        BOOST_TEST(false);
++    }
++
++    if (!::boost::detail::test_errors()) {
++        std::clog << "C++ type conversions: \x1b[1;32m \x1b[0m\n";
++#if BOOST_VERSION >= 104600
++        ::boost::detail::report_errors_remind().called_report_errors_function = true;
++#endif
++    } else {
++        return ::boost::report_errors();
++    }
++}
+diff --git a/tests/cpp_tests/label_algo_test.cpp b/tests/cpp_tests/label_algo_test.cpp
+index d43651a..cf7a0d4 100644
+--- a/tests/cpp_tests/label_algo_test.cpp
++++ b/tests/cpp_tests/label_algo_test.cpp
+@@ -31,6 +31,9 @@ int main( int, char*[] )
+     BOOST_TEST( x == 25 );
+     BOOST_TEST( y == 25 );
+     
++    // TODO - centroid and interior should be equal but they appear not to be (check largest)
++    // MULTIPOLYGON(((-52 40,-60 32,-68 40,-60 48,-52 40)),((-60 50,-80 30,-100 49.9999999999999,-80.0000000000001 70,-60 50)),((-52 60,-60 52,-68 60,-60 68,-52 60)))
++
+     if (!::boost::detail::test_errors()) {
+         std::clog << "C++ label algorithms: \x1b[1;32m \x1b[0m\n";
+ #if BOOST_VERSION >= 104600
+diff --git a/tests/python_tests/filter_test.py b/tests/python_tests/filter_test.py
+index 3480d7d..20105b3 100644
+--- a/tests/python_tests/filter_test.py
++++ b/tests/python_tests/filter_test.py
+@@ -20,9 +20,9 @@ map_ = '''<Map>
+ 
+             <![CDATA[
+ 
+-            ([region] >= 0) 
++            ([region] >= 0)
+ 
+-            and 
++            and
+ 
+             ([region] <= 50)
+             ]]>
+@@ -49,7 +49,7 @@ map_ = '''<Map>
+     </Style>
+ </Map>'''
+ 
+-def test_filter_init():    
++def test_filter_init():
+     m = mapnik.Map(1,1)
+     mapnik.load_map_from_string(m,map_)
+     filters = []
+@@ -74,7 +74,7 @@ def test_filter_init():
+     0)
+     and
+     ([region]
+-    <= 
++    <=
+     50)
+     '''))
+ 
+@@ -169,13 +169,17 @@ def test_float_precision():
+     context = mapnik.Context()
+     context.push('num')
+     f = mapnik.Feature(context,0)
+-    f["num"] = 1.0000
+-    eq_(f["num"],1.0000)
+-    expr = mapnik.Expression("[num] = 1.0000")
++    f["num1"] = 1.0000
++    f["num2"] = 1.0001
++    eq_(f["num1"],1.0000)
++    eq_(f["num2"],1.0001)
++    expr = mapnik.Expression("[num1] = 1.0000")
+     eq_(expr.evaluate(f),True)
+-    expr = mapnik.Expression("[num].match('.*0$')")
++    expr = mapnik.Expression("[num1].match('1')")
+     eq_(expr.evaluate(f),True)
+-    expr = mapnik.Expression("[num].match('.*0$')")
++    expr = mapnik.Expression("[num2] = 1.0001")
++    eq_(expr.evaluate(f),True)
++    expr = mapnik.Expression("[num2].match('1.0001')")
+     eq_(expr.evaluate(f),True)
+ 
+ def test_string_matching_on_precision():
+diff --git a/tests/python_tests/geometry_io_test.py b/tests/python_tests/geometry_io_test.py
+index f69c706..b6def27 100644
+--- a/tests/python_tests/geometry_io_test.py
++++ b/tests/python_tests/geometry_io_test.py
+@@ -14,7 +14,7 @@ def setup():
+ 
+ wkts = [
+     [1,"POINT(30 10)"],
+-    [1,"POINT(30.0 10.0)"],
++    [1,"POINT(30 10)"],
+     [1,"POINT(30.1 10.1)"],
+     [1,"LINESTRING(30 10,10 30,40 40)"],
+     [1,"POLYGON((30 10,10 20,20 40,40 40,30 10))"],
+@@ -61,7 +61,7 @@ wkbs = [
+ ]
+ 
+ geojson = [
+-[1,'{"type":"Point","coordinates":[30.0,10.0]}'],
++[1,'{"type":"Point","coordinates":[30,10]}'],
+ [1,'{"type":"Point","coordinates":[30.0,10.0]}'],
+ [1,'{"type":"Point","coordinates":[30.1,10.1]}'],
+ [1,'{"type":"LineString","coordinates":[[30.0,10.0],[10.0,30.0],[40.0,40.0]]}'],
+diff --git a/tests/python_tests/object_test.py b/tests/python_tests/object_test.py
+index 7884322..b672f3e 100644
+--- a/tests/python_tests/object_test.py
++++ b/tests/python_tests/object_test.py
+@@ -97,7 +97,7 @@ def test_text_symbolizer():
+ 
+     # old args required method
+     ts = mapnik.TextSymbolizer(mapnik.Expression('[Field_Name]'), 'Font Name', 8, mapnik.Color('black'))
+-#    eq_(str(ts.name), str(mapnik2.Expression('[Field_Name]'))) name field is no longer supported
++    eq_(str(ts.name), str(mapnik.Expression('[Field_Name]'))) 
+     eq_(ts.format.face_name, 'Font Name')
+     eq_(ts.format.text_size, 8)
+     eq_(ts.format.fill, mapnik.Color('black'))
+@@ -112,7 +112,7 @@ def test_shield_symbolizer_init():
+     eq_(s.allow_overlap, False)
+     eq_(s.avoid_edges, False)
+     eq_(s.character_spacing,0)
+-    #eq_(str(s.name), str(mapnik2.Expression('[Field Name]'))) name field is no longer supported
++    eq_(str(s.name), str(mapnik.Expression('[Field Name]')))
+     eq_(s.face_name, 'DejaVu Sans Bold')
+     eq_(s.allow_overlap, False)
+     eq_(s.fill, mapnik.Color('#000000'))
+@@ -155,7 +155,7 @@ def test_shield_symbolizer_init():
+     # 11c34b1: default transform list is empty, not identity matrix
+     eq_(s.transform, '')
+ 
+-    eq_(len(s.fontset.names), 0)
++    eq_(s.fontset, None)
+ 
+ # ShieldSymbolizer missing image file
+ # images paths are now PathExpressions are evaluated at runtime
+@@ -170,11 +170,11 @@ def test_shield_symbolizer_modify():
+     def check_transform(expr, expect_str=None):
+         s.transform = expr
+         eq_(s.transform, expr if expect_str is None else expect_str)
+-    check_transform("matrix(1 2 3 4 5 6)", "matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)")
++    check_transform("matrix(1 2 3 4 5 6)", "matrix(1, 2, 3, 4, 5, 6)")
+     check_transform("matrix(1, 2, 3, 4, 5, 6 +7)", "matrix(1, 2, 3, 4, 5, (6+7))")
+     check_transform("rotate([a])")
+     check_transform("rotate([a] -2)", "rotate(([a]-2))")
+-    check_transform("rotate([a] -2 -3)", "rotate([a], -2.0, -3.0)")
++    check_transform("rotate([a] -2 -3)", "rotate([a], -2, -3)")
+     check_transform("rotate([a] -2 -3 -4)", "rotate(((([a]-2)-3)-4))")
+     check_transform("rotate([a] -2, 3, 4)", "rotate(([a]-2), 3, 4)")
+     check_transform("translate([tx]) rotate([a])")
+@@ -209,6 +209,7 @@ def test_markers_symbolizer():
+     eq_(p.fill_opacity,None)
+     eq_(p.filename,'shape://ellipse')
+     eq_(p.placement,mapnik.marker_placement.POINT_PLACEMENT)
++    eq_(p.multi_policy,mapnik.marker_multi_policy.EACH)
+     eq_(p.fill,None)
+     eq_(p.ignore_placement,False)
+     eq_(p.spacing,100)
+@@ -218,7 +219,7 @@ def test_markers_symbolizer():
+     eq_(p.transform,'')
+     eq_(p.clip,True)
+     eq_(p.comp_op,mapnik.CompositeOp.src_over)
+-    
++
+ 
+     p.width = mapnik.Expression('12')
+     p.height = mapnik.Expression('12')
+@@ -239,10 +240,14 @@ def test_markers_symbolizer():
+     p.allow_overlap = True
+     p.opacity = 0.5
+     p.fill_opacity = 0.5
++    p.placement = mapnik.marker_placement.LINE_PLACEMENT
++    p.multi_policy = mapnik.marker_multi_policy.WHOLE
+ 
+     eq_(p.allow_overlap, True)
+     eq_(p.opacity, 0.5)
+     eq_(p.fill_opacity, 0.5)
++    eq_(p.multi_policy,mapnik.marker_multi_policy.WHOLE)
++    eq_(p.placement,mapnik.marker_placement.LINE_PLACEMENT)
+ 
+     #https://github.com/mapnik/mapnik/issues/1285
+     #https://github.com/mapnik/mapnik/issues/1427
+diff --git a/tests/python_tests/query_test.py b/tests/python_tests/query_test.py
+index ec636da..966d587 100644
+--- a/tests/python_tests/query_test.py
++++ b/tests/python_tests/query_test.py
+@@ -17,6 +17,10 @@ def test_query_init():
+     r = query.resolution
+     assert_almost_equal(r[0], 1.0, places=7)
+     assert_almost_equal(r[1], 1.0, places=7)
++    # https://github.com/mapnik/mapnik/issues/1762
++    eq_(query.property_names,[])
++    query.add_property_name('migurski')
++    eq_(query.property_names,['migurski'])
+ 
+ # Converting *from* tuples *to* resolutions is not yet supported
+ @raises(TypeError)
+diff --git a/tests/python_tests/test_fontset.py b/tests/python_tests/test_fontset.py
+index ec44a10..4db8ca7 100644
+--- a/tests/python_tests/test_fontset.py
++++ b/tests/python_tests/test_fontset.py
+@@ -17,6 +17,25 @@ def test_loading_fontset_from_map():
+     eq_(len(fs.names),2)
+     eq_(list(fs.names),['DejaVu Sans Book','DejaVu Sans Oblique'])
+ 
++def test_loading_fontset_from_python():
++    m = mapnik.Map(256,256)
++    fset = mapnik.FontSet('foo')
++    fset.add_face_name('Comic Sans')
++    fset.add_face_name('Papyrus')
++    eq_(fset.name,'foo')
++    fset.name = 'my-set'
++    eq_(fset.name,'my-set')
++    m.append_fontset('my-set', fset)
++    sty = mapnik.Style()
++    rule = mapnik.Rule()
++    tsym = mapnik.TextSymbolizer()
++    eq_(tsym.fontset,None)
++    tsym.fontset = fset
++    rule.symbols.append(tsym)
++    sty.rules.append(rule)
++    m.append_style('Style',sty)
++    serialized_map = mapnik.save_map_to_string(m)
++    eq_('fontset-name="my-set"' in serialized_map,True)
+ 
+ if __name__ == "__main__":
+     setup()
+diff --git a/tests/run_tests.py b/tests/run_tests.py
+index 24db67b..b240612 100755
+--- a/tests/run_tests.py
++++ b/tests/run_tests.py
+@@ -5,7 +5,7 @@ import sys
+ try:
+     import nose
+ except ImportError:
+-    sys.stderr.write("Unable to run python tests: the third party 'nose' module is required\nTo install 'nose' do:\n\tsudo pip install nose (or on debian systems: apt-get install python-nose\n")
++    sys.stderr.write("Unable to run python tests: the third party 'nose' module is required\nTo install 'nose' do:\n\tsudo pip install nose (or on debian systems: apt-get install python-nose)\n")
+     sys.exit(1)
+     
+ from python_tests.utilities import TodoPlugin
+diff --git a/tests/visual_tests/data/marker-multi-policy.csv b/tests/visual_tests/data/marker-multi-policy.csv
+new file mode 100644
+index 0000000..42ca2f9
+--- /dev/null
++++ b/tests/visual_tests/data/marker-multi-policy.csv
+@@ -0,0 +1,3 @@
++i|wkt
++1|MULTIPOLYGON(((90 40,50 0,10 40,50 80,90 40)),((190 40,150 0,110 40,150 80,190 40)),((190 140,150 100,110 140,150 180,190 140)))
++2|MULTIPOLYGON(((48 130,40 122,32 130,40 138,48 130)),((40 140,20 120,0 140,20 160,40 140)),((48 150,40 142,32 150,40 158,48 150)))
+\ No newline at end of file
+diff --git a/tests/visual_tests/data/marker-on-line.csv b/tests/visual_tests/data/marker-on-line.csv
+new file mode 100644
+index 0000000..4835d65
+--- /dev/null
++++ b/tests/visual_tests/data/marker-on-line.csv
+@@ -0,0 +1,2 @@
++i|wkt
++1|LINESTRING(-10  0, 0 20, 10 0, 15 5)
+diff --git a/tests/visual_tests/data/whole-centroid.csv b/tests/visual_tests/data/whole-centroid.csv
+new file mode 100644
+index 0000000..f630955
+--- /dev/null
++++ b/tests/visual_tests/data/whole-centroid.csv
+@@ -0,0 +1,2 @@
++i|wkt
++1|MULTIPOLYGON(((1350057.96009438 5942345.52058283,1384876.13646624 5891754.2133652,1527153.68896859 5865144.36766544,1489794.86785838 5828107.21457916,1521644.71000822 5808839.16705438,1500586.73589334 5782129.46376012,1549474.58270654 5722446.94649062,1526963.22131985 5715859.64352432,1468675.11142609 5744853.11521536,1367157.74707515 5695509.5055605,1353768.57268098 5663160.88833932,1395853.46277285 5615400.34143299,1363168.83576153 5576894.81504537,1376836.42020216 5503694.0028362,1516356.92287605 5396662.575031,1560328.12173938 5261876.31080913,1640818.23615492 5173802.74601002,1796912.65253506 5148129.98779792,1773597.67574436 5083111.70893878,2005049.37613903 4960037.26198969,2060770.68121407 4885821.98463312,2042650.53978071 4835753.32622244,1988073.15379307 4907241.27057499,1882814.34135654 4930901.063827,1835287.04135981 4832212.44229475,1909252.60910046 4777690.54700568,1911262.92778469 4716420.6995481,1847346.61575592 4693181.77244718,1788068.875589 4568718.26175616,1740109.09937055 4581073.81722757,1805880.43939388 4708906.48580766,1744005.2815483 4870423.42300908,1235522.56053157 5220039.63151647,1125161.53055404 5466602.89896275,973921.757167397 5532097.82173426,838019.24926376 5432786.3871293,852954.651385017 5491916.6901273,776607.959736312 5509523.04321204,782761.478548388 5595015.13624148,736908.312373676 5638877.1573602,793460.506128018 5662194.42680345,756857.878318762 5745270.82868898,783472.587455564 5769448.93739922,874497.199243332 5767386.72200479,939134.416294499 5854912.10535634,1005956.9462694 5754390.71173147,1033261.27965169 5860165.00562569,1127666.33041638 5816836.29071798,1118791.82929085 5867309.80784728,1164989.30665057 5868344.65660203,1165652.54817671 5921100.82966656,1350057.96009438 5942345.52058283),(1386948.01482887 5449379.17151171,1392606.60718488 5463421.03119553,1382120.31115215 5458937.77184712,1386948.01482887 5449379.17151171),(1385381.11851082 5146477.94829492,1386669.06721543 5146224.9584086,1386111.70929647 5147206.59661607,1385381.11851082 5146477.94829492)),((1382897.20987839 5687974.04417046,1371857.98993491 5675822.90372079,1377393.1289756 5689163.60754804,1382897.20987839 5687974.04417046)),((1095847.54640445 5317215.2838641,1091704.01231816 5313451.44710224,1091394.65545324 5321701.46563701,1094455.94145006 5323479.01597989,1095847.54640445 5317215.2838641)),((1162299.15983606 5288324.53042776,1160289.06379081 5267765.62824438,1124543.26210218 5277407.73480368,1162299.15983606 5288324.53042776)),((1123028.09251298 5247084.38946664,1122316.87228631 5254141.60947014,1124512.20396424 5250317.54284925,1123028.09251298 5247084.38946664)),((1215144.97114443 5209828.83212963,1209640.77892215 5214848.8689761,1210908.5966028 5219286.46510058,1215144.97114443 5209828.83212963)),((1148446.00580429 5208658.24432317,1145817.64130717 5213552.48912728,1149497.41839483 5212548.16532901,1148446.00580429 5208658.24432317)),((1059019.27398736 5033998.10699295,1093806.61486026 4942691.99568292,1065234.68643633 4743259.71214946,1003916.12604469 4759901.51823648,986197.736653606 4704377.88889769,935856.725207561 4715744.68629496,952523.590688621 4846503.91226084,911984.817004403 4999606.76073705,1059019.27398736 5033998.10699295)),((928311.824080081 5021563.59386512,914520.452365687 5011234.44611049,926301.728034833 5030262.29618597,928311.824080081 5021563.59386512)),((1443164.46899898 4995230.22633471,1441618.24127186 5000220.31310592,1445823.55767554 5002226.81825718,1443164.46899898 4995230.22633471)),((1553061.29669992 4968395.29665014,1542207.75766705 4973291.02362767,1552690.38015659 4974433.31609162,1553061.29669992 4968395.29665014)),((1581911.63517033 4947738.11891254, 1587632.34380218 4947004.77788114,1580427.52371907 4944237.33055168,1581911.63517033 4947738.11891254)),((923085.819265294 4735088.56864719,915479.024500905 4745293.69583645,924260.796490606 4748923.38178062,923085.819265294 4735088.56864719)),((1693571.31832746 4688858.4894456,1690973.90064878 4691713.90965507,1696416.19923417 4693935.9965921,1693571.31832746 4688858.4894456)),((1466448.61029075 4677403.01590106,1465211.85074803 4680849.56314581,1469231.59756058 4680414.29421003,1466448.61029075 4677403.01590106)),((1655135.14718535 4654767.34922581,1646940.91946804 4659946.37928978,1655166.09400377 4661409.67928983,1655135.14718535 4654767.34922581)),((1664813.70899286 4642559.56041499,1660020.95963625 4652672.28390196,1665772.39244759 4652790.51476716,1664813.70899286 4642559.56041499)),((1668555.37971741 4630998.75869634,1663236.86840579 4636007.55629286,1665215.68367412 4640507.06235257,1668555.37971741 4630998.75869634)),((1728668.01606527 4598788.94471507,1679439.97688818 4506146.77040914,1705043.45977066 4440345.73224938,1678852.4326158 4390316.66779138,1382835.42756099 4550662.053593,1482404.47818411 4610314.59733156,1532745.60094962 4575266.49172867,1728668.01606527 4598788.94471507)),((1344059.17537453 4572873.96816367,1339173.36292359 4577580.75464391,1342420.21851156 4577895.44505675,1344059.17537453 4572873.96816367)),((1375259.46829558 4566170.07673534,1366044.55216722 4570443.18173048,1373589.78725316 4570168.66006012,1375259.46829558 4566170.07673534)),((1337596.41101701 4402695.43852239,1328134.14298011 4415398.45409661,1341214.18314831 4410841.06668909,1337596.41101701 4402695.43852239)))
+diff --git a/tests/visual_tests/images/marker-multi-policy-600-reference.png b/tests/visual_tests/images/marker-multi-policy-600-reference.png
+new file mode 100644
+index 0000000..70f959c
+Binary files /dev/null and b/tests/visual_tests/images/marker-multi-policy-600-reference.png differ
+diff --git a/tests/visual_tests/images/marker-on-line-600-reference.png b/tests/visual_tests/images/marker-on-line-600-reference.png
+new file mode 100644
+index 0000000..b9893f5
+Binary files /dev/null and b/tests/visual_tests/images/marker-on-line-600-reference.png differ
+diff --git a/tests/visual_tests/images/marker_line_placement_on_points-500-reference.png b/tests/visual_tests/images/marker_line_placement_on_points-500-reference.png
+new file mode 100644
+index 0000000..71b1fb1
+Binary files /dev/null and b/tests/visual_tests/images/marker_line_placement_on_points-500-reference.png differ
+diff --git a/tests/visual_tests/images/whole-centroid-600-reference.png b/tests/visual_tests/images/whole-centroid-600-reference.png
+new file mode 100644
+index 0000000..500bd4c
+Binary files /dev/null and b/tests/visual_tests/images/whole-centroid-600-reference.png differ
+diff --git a/tests/visual_tests/styles/marker-multi-policy.xml b/tests/visual_tests/styles/marker-multi-policy.xml
+new file mode 100644
+index 0000000..937cc15
+--- /dev/null
++++ b/tests/visual_tests/styles/marker-multi-policy.xml
+@@ -0,0 +1,36 @@
++<Map maximum-extent="0,0,190,180">
++<Style name="each">
++  <Rule>
++    <Filter>[i] = 1</Filter>
++    <MarkersSymbolizer placement="point" fill="red" width="30" allow-overlap="true"/>
++  </Rule>
++</Style>
++<Style name="whole">
++  <Rule>
++    <Filter>[i] = 1</Filter>
++    <MarkersSymbolizer placement="point" multi-policy="whole" fill="yellow" width="20" allow-overlap="true"/>
++  </Rule>
++</Style>
++<Style name="largest">
++  <Rule>
++    <Filter>[i] = 2</Filter>
++    <MarkersSymbolizer placement="point" multi-policy="largest" fill="blue" width="10" allow-overlap="true"/>
++  </Rule>
++</Style>
++<Style name="boundary">
++  <Rule>
++    <LineSymbolizer />
++  </Rule>
++</Style>
++<Layer name="multi">
++    <StyleName>boundary</StyleName>
++    <StyleName>each</StyleName>
++    <StyleName>whole</StyleName>
++    <StyleName>largest</StyleName>
++    <Datasource>
++       <Parameter name="type">csv</Parameter>
++       <Parameter name="file">../data/marker-multi-policy.csv</Parameter>
++       <Parameter name="separator">|</Parameter>
++    </Datasource>
++  </Layer>
++</Map>
+diff --git a/tests/visual_tests/styles/marker-on-line.xml b/tests/visual_tests/styles/marker-on-line.xml
+new file mode 100644
+index 0000000..1ca8ada
+--- /dev/null
++++ b/tests/visual_tests/styles/marker-on-line.xml
+@@ -0,0 +1,21 @@
++<Map>
++<Style name="line" filter-mode="first" >
++  <Rule>
++    <LineSymbolizer stroke="#000000" />
++  </Rule>
++</Style>
++<Style name="point-placement" filter-mode="first" >
++  <Rule>
++    <MarkersSymbolizer placement="point" marker-type="ellipse" fill="blue" />
++  </Rule>
++</Style>
++<Layer name="carto_tests">
++    <StyleName>line</StyleName>
++    <StyleName>point-placement</StyleName>
++    <Datasource>
++       <Parameter name="type">csv</Parameter>
++       <Parameter name="file">../data/marker-on-line.csv</Parameter>
++       <Parameter name="separator">|</Parameter>
++    </Datasource>
++  </Layer>
++</Map>
+diff --git a/tests/visual_tests/styles/marker_line_placement_on_points.xml b/tests/visual_tests/styles/marker_line_placement_on_points.xml
+new file mode 100644
+index 0000000..db11328
+--- /dev/null
++++ b/tests/visual_tests/styles/marker_line_placement_on_points.xml
+@@ -0,0 +1,36 @@
++<!DOCTYPE Map>
++<Map background-color="white" srs="+init=epsg:4326" minimum-version="0.7.2">
++
++    <Style name="1">
++        <Rule>
++          <Filter>[id]=1</Filter>
++          <MarkersSymbolizer fill="darkgreen" opacity=".7" width="15" height="10" stroke="green" stroke-width="7" stroke-opacity=".2" placement="line" marker-type="ellipse"/>
++        </Rule>
++        <Rule>
++          <Filter>[id]=2</Filter>
++             <MarkersSymbolizer fill="darkorange" opacity=".7" width="20" height="10" stroke="orange" stroke-width="7" stroke-opacity=".2" placement="line" marker-type="ellipse"/>
++        </Rule>
++        <Rule>
++          <Filter>[id]=3</Filter>
++             <MarkersSymbolizer fill="darkred" opacity=".7" width="20" height="10" stroke="orange" stroke-width="7" stroke-opacity=".2" placement="line" marker-type="ellipse"/>
++        </Rule>
++    </Style>
++    <Layer name="point" srs="+init=epsg:4326">
++        <StyleName>1</StyleName>
++        <Datasource>
++            <Parameter name="type">csv</Parameter>
++            <Parameter name="inline">
++            x,y,id
++            0,0,1
++            5,0,1
++            5,5,1
++            0,5,1
++            2.5,2.5,2
++            2.5,3,3
++            2.5,2,3
++            3,2.5,3
++            2,2.5,3
++            </Parameter>
++        </Datasource>
++    </Layer>
++</Map>
+\ No newline at end of file
+diff --git a/tests/visual_tests/styles/whole-centroid.xml b/tests/visual_tests/styles/whole-centroid.xml
+new file mode 100644
+index 0000000..ed692a8
+--- /dev/null
++++ b/tests/visual_tests/styles/whole-centroid.xml
+@@ -0,0 +1,21 @@
++<Map maximum-extent="736908, 4390316, 2060771, 5942346">
++<Style name="whole">
++  <Rule>
++    <MarkersSymbolizer placement="point" multi-policy="whole" fill="yellow" width="20" allow-overlap="true"/>
++  </Rule>
++</Style>
++<Style name="boundary">
++  <Rule>
++    <LineSymbolizer />
++  </Rule>
++</Style>
++<Layer name="multi">
++    <StyleName>boundary</StyleName>
++    <StyleName>whole</StyleName>
++    <Datasource>
++       <Parameter name="type">csv</Parameter>
++       <Parameter name="file">../data/whole-centroid.csv</Parameter>
++       <Parameter name="separator">|</Parameter>
++    </Datasource>
++  </Layer>
++</Map>
+diff --git a/tests/visual_tests/test.py b/tests/visual_tests/test.py
+index 0f9fc06..ec05fde 100755
+--- a/tests/visual_tests/test.py
++++ b/tests/visual_tests/test.py
+@@ -27,6 +27,14 @@ files = [
+     {'name': "lines-2", 'sizes': sizes_few_square},
+     {'name': "lines-3", 'sizes': sizes_few_square},
+     {'name': "lines-shield", 'sizes': sizes_few_square},
++    {'name': "marker-multi-policy", 'sizes':[(600,400)],
++        'bbox': mapnik.Box2d(0, 0, 190, 180)},
++    {'name': "marker-on-line", 'sizes':[(600,400)],
++        'bbox': mapnik.Box2d(-10, 0, 15, 20)},
++    {'name': "marker_line_placement_on_points", 'sizes':[(500,100)],
++        'bbox': mapnik.Box2d(0, 0, 5, 5)},
++    {'name': "whole-centroid", 'sizes':[(600,400)],
++        'bbox': mapnik.Box2d(736908, 4390316, 2060771, 5942346)},
+     {'name': "simple-E"},
+     {'name': "simple-NE"},
+     {'name': "simple-NW"},
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik/__init__.py upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik/__init__.py
--- v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik/__init__.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik/__init__.py	2013-06-01 19:23:19.814004411 +0200
@@ -699,6 +699,18 @@
 
 class _TextSymbolizer(TextSymbolizer,_injector):
     @property
+    def name(self):
+        if isinstance(self.properties.format_tree, FormattingText):
+            return self.properties.format_tree.text
+        else:
+            # There is no single expression which could be returned as name
+            raise RuntimeError("TextSymbolizer uses complex formatting features, but old compatibility interface is used to access it. Use self.properties.format_tree instead.")
+
+    @name.setter
+    def name(self, name):
+        self.properties.format_tree = FormattingText(name)
+
+    @property
     def text_size(self):
         warnings.warn("'text_size' is deprecated, use format.text_size",
         DeprecationWarning, 2)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_fontset.cpp upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_fontset.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_fontset.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_fontset.cpp	2013-06-01 19:23:19.814004411 +0200
@@ -33,8 +33,13 @@
 void export_fontset ()
 {
     using namespace boost::python;
-    class_<font_set>("FontSet", init<>("default fontset constructor")
+    class_<font_set>("FontSet", init<std::string const&>("default fontset constructor")
         )
+        .add_property("name",
+                       make_function(&font_set::get_name,return_value_policy<copy_const_reference>()),
+                       &font_set::set_name,
+                      "Get/Set the name of the FontSet.\n"
+            )
         .def("add_face_name",&font_set::add_face_name,
              (arg("name")),
              "Add a face-name to the fontset.\n"
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_markers_symbolizer.cpp upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_markers_symbolizer.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_markers_symbolizer.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_markers_symbolizer.cpp	2013-06-01 19:23:19.818004340 +0200
@@ -89,6 +89,12 @@
         .value("LINE_PLACEMENT",mapnik::MARKER_LINE_PLACEMENT)
         ;
 
+    mapnik::enumeration_<mapnik::marker_multi_policy_e>("marker_multi_policy")
+        .value("EACH",mapnik::MARKER_EACH_MULTI)
+        .value("WHOLE",mapnik::MARKER_WHOLE_MULTI)
+        .value("LARGEST",mapnik::MARKER_LARGEST_MULTI)
+        ;
+
     class_<markers_symbolizer>("MarkersSymbolizer",
                                init<>("Default Markers Symbolizer - circle"))
         .def (init<mapnik::path_expression_ptr>("<path expression ptr>"))
@@ -143,6 +149,10 @@
                       &markers_symbolizer::get_marker_placement,
                       &markers_symbolizer::set_marker_placement,
                       "Set/get the marker placement")
+        .add_property("multi_policy",
+                      &markers_symbolizer::get_marker_multi_policy,
+                      &markers_symbolizer::set_marker_multi_policy,
+                      "Set/get the marker multi geometry rendering policy")
         .add_property("comp_op",
                       &markers_symbolizer::comp_op,
                       &markers_symbolizer::set_comp_op,
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_python.cpp upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_python.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_python.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_python.cpp	2013-06-01 19:23:19.818004340 +0200
@@ -295,6 +295,16 @@
     PyErr_SetString(PyExc_RuntimeError, ex.what());
 }
 
+void out_of_range_error_translator(std::out_of_range const & ex)
+{
+    PyErr_SetString(PyExc_IndexError, ex.what());
+}
+
+void standard_error_translator(std::exception const & ex)
+{
+    PyErr_SetString(PyExc_RuntimeError, ex.what());
+}
+
 unsigned mapnik_version()
 {
     return MAPNIK_VERSION;
@@ -364,6 +374,8 @@
     using mapnik::save_map_to_string;
     using mapnik::render_grid;
 
+    register_exception_translator<std::exception>(&standard_error_translator);
+    register_exception_translator<std::out_of_range>(&out_of_range_error_translator);
     register_exception_translator<mapnik::config_error>(&config_error_translator);
     register_exception_translator<mapnik::value_error>(&value_error_translator);
     register_exception_translator<std::runtime_error>(&runtime_error_translator);
@@ -617,6 +629,7 @@
     def("has_pycairo", &has_pycairo, "Get pycairo module status");
 
     python_optional<mapnik::stroke>();
+    python_optional<mapnik::font_set>();
     python_optional<mapnik::color>();
     python_optional<mapnik::box2d<double> >();
     python_optional<mapnik::composite_mode_e>();
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_query.cpp upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_query.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_query.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_query.cpp	2013-06-01 19:23:19.818004340 +0200
@@ -22,11 +22,15 @@
 
 // boost
 #include <boost/python.hpp>
+#include <boost/foreach.hpp>
 
 // mapnik
 #include <mapnik/query.hpp>
 #include <mapnik/box2d.hpp>
 
+#include <string>
+#include <set>
+
 using mapnik::query;
 using mapnik::box2d;
 
@@ -46,11 +50,30 @@
     }
 };
 
+struct names_to_list
+{
+    static PyObject* convert(std::set<std::string> const& names)
+    {
+        boost::python::list l;
+        BOOST_FOREACH( std::string const& name, names )
+        {
+            l.append(name);
+        }
+        return python::incref(l.ptr());
+    }
+
+    static PyTypeObject const* get_pytype()
+    {
+        return &PyList_Type;
+    }
+};
+
 void export_query()
 {
     using namespace boost::python;
 
     to_python_converter<query::resolution_type, resolution_to_tuple> ();
+    to_python_converter<std::set<std::string>, names_to_list> ();
 
     class_<query>("Query", "a spatial query data object",
                   init<box2d<double>,query::resolution_type const&,double>() )
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_text_placement.cpp upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_text_placement.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/bindings/python/mapnik_text_placement.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/bindings/python/mapnik_text_placement.cpp	2013-06-01 19:23:19.818004340 +0200
@@ -402,9 +402,9 @@
     class_with_converter<char_properties>
         ("CharProperties")
         .def_readwrite_convert("text_transform", &char_properties::text_transform)
+        .def_readwrite_convert("fontset", &char_properties::fontset)
         .def(init<char_properties const&>()) //Copy constructor
         .def_readwrite("face_name", &char_properties::face_name)
-        .def_readwrite("fontset", &char_properties::fontset)
         .def_readwrite("text_size", &char_properties::text_size)
         .def_readwrite("character_spacing", &char_properties::character_spacing)
         .def_readwrite("line_spacing", &char_properties::line_spacing)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/CHANGELOG.md upstream/mapnik-mapnik-ef297c6/CHANGELOG.md
--- v2.1.0/mapnik-mapnik-ef297c6/CHANGELOG.md	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/CHANGELOG.md	2013-06-01 19:23:19.810004482 +0200
@@ -7,6 +7,17 @@
 For a complete change history, see the git log.
 
 
+## Unreleased
+
+- Added serialization of `line-offset` to save_map (#1562)
+
+- Added support for controlling rendering behavior of markers on multi-geometries `marker-multi-policy` (#1555,#1573)
+
+- Add DebugSymbolizer (#1366)
+
+- Added support for literal types in PostGIS Plugin (#1464)
+
+
 ## Mapnik 2.1.0
 
 Released Aug 23, 2012
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vcgen.h upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vcgen.h
--- v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vcgen.h	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vcgen.h	2013-06-01 19:23:19.882003213 +0200
@@ -29,6 +29,7 @@
 
         void rewind(unsigned) {}
         unsigned vertex(double*, double*) { return path_cmd_stop; }
+        unsigned type() const { return 0; }
     };
 
 
@@ -64,6 +65,7 @@
         }
 
         unsigned vertex(double* x, double* y);
+        unsigned type() const { return m_source->type(); }
 
     private:
         // Prohibit copying
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vpgen.h upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vpgen.h
--- v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vpgen.h	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_adaptor_vpgen.h	2013-06-01 19:23:19.882003213 +0200
@@ -33,6 +33,7 @@
 
         void rewind(unsigned path_id);
         unsigned vertex(double* x, double* y);
+        unsigned type() const { return m_source->type(); }
 
     private:
         conv_adaptor_vpgen(const conv_adaptor_vpgen<VertexSource, VPGen>&);
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polygon.h upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polygon.h
--- v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polygon.h	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polygon.h	2013-06-01 19:23:19.882003213 +0200
@@ -51,6 +51,7 @@
         double y1() const { return base_type::vpgen().y1(); }
         double x2() const { return base_type::vpgen().x2(); }
         double y2() const { return base_type::vpgen().y2(); }
+        unsigned type() const { return base_type::type(); }
 
     private:
         conv_clip_polygon(const conv_clip_polygon<VertexSource>&);
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polyline.h upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polyline.h
--- v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polyline.h	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_clip_polyline.h	2013-06-01 19:23:19.882003213 +0200
@@ -51,6 +51,7 @@
         double y1() const { return base_type::vpgen().y1(); }
         double x2() const { return base_type::vpgen().x2(); }
         double y2() const { return base_type::vpgen().y2(); }
+        unsigned type() const { return base_type::type(); }
 
     private:
         conv_clip_polyline(const conv_clip_polyline<VertexSource>&);
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_smooth_poly1.h upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_smooth_poly1.h
--- v2.1.0/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_smooth_poly1.h	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/deps/agg/include/agg_conv_smooth_poly1.h	2013-06-01 19:23:19.882003213 +0200
@@ -42,6 +42,7 @@
 
         void   smooth_value(double v) { base_type::generator().smooth_value(v); }
         double smooth_value() const { return base_type::generator().smooth_value(); }
+        unsigned type() const { return base_type::type(); }
 
     private:
         conv_smooth_poly1(const conv_smooth_poly1<VertexSource>&);
@@ -64,6 +65,7 @@
 
         void   smooth_value(double v) { m_smooth.generator().smooth_value(v); }
         double smooth_value() const { return m_smooth.generator().smooth_value(); }
+        unsigned type() const { return m_smooth.type(); }
 
     private:
         conv_smooth_poly1_curve(const conv_smooth_poly1_curve<VertexSource>&);
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/fonts/build.py upstream/mapnik-mapnik-ef297c6/fonts/build.py
--- v2.1.0/mapnik-mapnik-ef297c6/fonts/build.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/fonts/build.py	2013-06-01 19:23:19.902002861 +0200
@@ -22,15 +22,12 @@
 
 Import('env')
 
-# grab all the deja vu fonts
-includes = glob.glob('*/*/*.ttf')
-
-# grab single unifont ttf (available at http://unifoundry.com/unifont.html)
-includes.extend(glob.glob('unifont*.ttf'))
-
-target_path = env['MAPNIK_FONTS_DEST']
-
-if 'uninstall' not in COMMAND_LINE_TARGETS and not env['SYSTEM_FONTS']:
-    env.Alias(target='install', source=env.Install(target_path, includes))
-
-env['create_uninstall_target'](env, target_path)
\ Pas de fin de ligne  la fin du fichier
+if not env['SYSTEM_FONTS']:
+    # grab all the deja vu fonts
+    includes = glob.glob('*/*/*.ttf')
+    # grab single unifont ttf (available at http://unifoundry.com/unifont.html)
+    includes.extend(glob.glob('unifont*.ttf'))
+    target_path = env['MAPNIK_FONTS_DEST']
+    if 'uninstall' not in COMMAND_LINE_TARGETS:
+        env.Alias(target='install', source=env.Install(target_path, includes))
+    env['create_uninstall_target'](env, target_path)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/config upstream/mapnik-mapnik-ef297c6/.git/config
--- v2.1.0/mapnik-mapnik-ef297c6/.git/config	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/config	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = git@github.com:mapnik/mapnik.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "2.1.x"]
+	remote = origin
+	merge = refs/heads/2.1.x
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/description upstream/mapnik-mapnik-ef297c6/.git/description
--- v2.1.0/mapnik-mapnik-ef297c6/.git/description	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/description	2013-06-01 19:19:31.950016957 +0200
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/HEAD upstream/mapnik-mapnik-ef297c6/.git/HEAD
--- v2.1.0/mapnik-mapnik-ef297c6/.git/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/HEAD	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1 @@
+ref: refs/heads/2.1.x
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/applypatch-msg.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/applypatch-msg.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/applypatch-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/applypatch-msg.sample	2013-06-01 19:19:31.954016857 +0200
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/commit-msg.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/commit-msg.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/commit-msg.sample	2013-06-01 19:19:31.958016776 +0200
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/post-update.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/post-update.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/post-update.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/post-update.sample	2013-06-01 19:19:31.954016857 +0200
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/pre-applypatch.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/pre-applypatch.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/pre-applypatch.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/pre-applypatch.sample	2013-06-01 19:19:31.954016857 +0200
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/pre-commit.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/pre-commit.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/pre-commit.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/pre-commit.sample	2013-06-01 19:19:31.958016776 +0200
@@ -0,0 +1,50 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ascii filenames set this variable to true.
+allownonascii=$(git config hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ascii filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	echo "Error: Attempt to add a non-ascii file name."
+	echo
+	echo "This can cause problems if you want to work"
+	echo "with people on other platforms."
+	echo
+	echo "To be portable it is advisable to rename the file ..."
+	echo
+	echo "If you know what you are doing you can disable this"
+	echo "check using:"
+	echo
+	echo "  git config hooks.allownonascii true"
+	echo
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/prepare-commit-msg.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/prepare-commit-msg.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/prepare-commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/prepare-commit-msg.sample	2013-06-01 19:19:31.958016776 +0200
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/pre-rebase.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/pre-rebase.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/pre-rebase.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/pre-rebase.sample	2013-06-01 19:19:31.958016776 +0200
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/update.sample upstream/mapnik-mapnik-ef297c6/.git/hooks/update.sample
--- v2.1.0/mapnik-mapnik-ef297c6/.git/hooks/update.sample	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/hooks/update.sample	2013-06-01 19:19:31.954016857 +0200
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "Usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/.git/index et upstream/mapnik-mapnik-ef297c6/.git/index sont diffrents
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/info/exclude upstream/mapnik-mapnik-ef297c6/.git/info/exclude
--- v2.1.0/mapnik-mapnik-ef297c6/.git/info/exclude	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/info/exclude	2013-06-01 19:19:31.950016957 +0200
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/logs/HEAD upstream/mapnik-mapnik-ef297c6/.git/logs/HEAD
--- v2.1.0/mapnik-mapnik-ef297c6/.git/logs/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/logs/HEAD	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 3e70226a69e32e2282e405b61d0d679fd96370aa Mathieu Le Marec - Pasquet <kiorky@cryptelium.net> 1370107399 +0200	clone: from git@github.com:mapnik/mapnik.git
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/logs/refs/heads/2.1.x upstream/mapnik-mapnik-ef297c6/.git/logs/refs/heads/2.1.x
--- v2.1.0/mapnik-mapnik-ef297c6/.git/logs/refs/heads/2.1.x	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/logs/refs/heads/2.1.x	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 3e70226a69e32e2282e405b61d0d679fd96370aa Mathieu Le Marec - Pasquet <kiorky@cryptelium.net> 1370107399 +0200	clone: from git@github.com:mapnik/mapnik.git
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/logs/refs/remotes/origin/HEAD upstream/mapnik-mapnik-ef297c6/.git/logs/refs/remotes/origin/HEAD
--- v2.1.0/mapnik-mapnik-ef297c6/.git/logs/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/logs/refs/remotes/origin/HEAD	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 856ec4fd24128c61a0fc967b1cda6ab33a33db5c Mathieu Le Marec - Pasquet <kiorky@cryptelium.net> 1370107399 +0200	clone: from git@github.com:mapnik/mapnik.git
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/.git/objects/pack/pack-05fe258e00ce90c8d15427af5ae64017abffff04.idx et upstream/mapnik-mapnik-ef297c6/.git/objects/pack/pack-05fe258e00ce90c8d15427af5ae64017abffff04.idx sont diffrents
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/.git/objects/pack/pack-05fe258e00ce90c8d15427af5ae64017abffff04.pack et upstream/mapnik-mapnik-ef297c6/.git/objects/pack/pack-05fe258e00ce90c8d15427af5ae64017abffff04.pack sont diffrents
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/packed-refs upstream/mapnik-mapnik-ef297c6/.git/packed-refs
--- v2.1.0/mapnik-mapnik-ef297c6/.git/packed-refs	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/packed-refs	2013-06-01 19:23:19.766005257 +0200
@@ -0,0 +1,81 @@
+# pack-refs with: peeled 
+8226b30f1f51b16749990473006c1f4ffd347d19 refs/remotes/origin/0.7.x
+4acda0a752a4fc72d82a6f0fde503376de0a900d refs/remotes/origin/2.0.x
+3e70226a69e32e2282e405b61d0d679fd96370aa refs/remotes/origin/2.1.x
+a701f52e573b13121143524e2248fad3487787f3 refs/remotes/origin/PHOENIX_V3
+154c93017acece13d6b451286db12d6a16135b71 refs/remotes/origin/c++11
+106ce423094035e7f93dc511f1c8cac125612b67 refs/remotes/origin/clipping-off-for-placement
+ebcdd3cf90736330c05d7876c07a0a79200a5ad8 refs/remotes/origin/datasources
+0a588d044b721dfbe9cb560749b3cec0b3b8bb52 refs/remotes/origin/experimental-pdf
+55c0e3e0f24b7d7c9672c2e0ed622b89839807f3 refs/remotes/origin/gdaldataset
+54c7e64bc9768975babbe4307c0fd6aa73d3017c refs/remotes/origin/harfbuzz
+2320632f8751c19cd0822ad3e9d8725c7b15858d refs/remotes/origin/hb-halign
+f5227d7f18a1c2045c064cc897497d6ebe0e5530 refs/remotes/origin/incremental-images
+d33873d3b707b1bde1aae232070b083dec908d7b refs/remotes/origin/indexing-api
+b75ae3a16f9c5784ca37bdd863c8d8ef9f17dec6 refs/remotes/origin/layer-opacity
+bd70e9b6fff08b34c131db12590dabbf16089a93 refs/remotes/origin/mapnik-old
+99071d1253b0f1862776a1238694b9a4e501132c refs/remotes/origin/marker-refactor
+856ec4fd24128c61a0fc967b1cda6ab33a33db5c refs/remotes/origin/master
+9655491b7f95fb63cc6d0ea8e388571af18f0dde refs/remotes/origin/metawriter-renderer
+982a2b940ed7613c3555e3860c53c511a3a667a5 refs/remotes/origin/move_bind_logic_to_layer
+517bd42f287317c002dbd8750466e8c8e4fbfc08 refs/remotes/origin/optional-extent
+364341152c0c8246339ad01f342d917bf1040a68 refs/remotes/origin/oracle-next
+18633adc7e0d9c603bb83721fdd789cf69ef06e4 refs/remotes/origin/ptr_container
+a4675f2d530d6634c2350caf36fb3d166acb6728 refs/remotes/origin/remove-aspect-fix-mode
+fb2b1ae2f2796c759a07ff5cd9e93c5fe35fc561 refs/remotes/origin/remove-text-opacity
+da7a5f968470abd1a7bdccbb0b92ae081a5d33ce refs/remotes/origin/shape-threading-debug
+f3c8508c12dcbea6af0d35546ee6064aed58acff refs/remotes/origin/sotm2010
+a2ab9b5588875648da09674ee73a60ef130f8f02 refs/remotes/origin/statistics
+ad293b4ccaf94dcaf690f82a812d60c847509d92 refs/remotes/origin/statistics-tilemill
+37daca644aebc6118077e6262d92d3baa1383b11 refs/remotes/origin/stats_processor
+4d29a44e612b3453914eaeef182fff7c4d4bf4c9 refs/remotes/origin/stroke-width-expr
+1195cea620274db3184585f03b5a8a876aec4924 refs/tags/mapnik_2005_05_03
+^63f5e368f38f7e6525608f76aa0822a1a252664e
+5c90664d120402c15ae78f6a8314358bbeb5d7c3 refs/tags/pre_lgpl
+^6cd99a52ab950ad2096bef609386e93566851c4c
+64e840c1f9aa93cf9c97d18cd6232aaebc3e0dac refs/tags/pre_new_layout
+^66d6ea8c35ec04acb83cc7d6fe6c37d2a3bcfb43
+1908bdad64ab0530a9d098b827a359879247ce71 refs/tags/release-0.1alpha
+^f7bae6965e70a89bcee971b1cee185ba12249394
+d053103ed12ee7203b7d17f82011a56e4ea25038 refs/tags/release-0.1alpha@14
+^ea62b41be4ffc26b42fd9ad120e8b40f0b721a3b
+434b9ee79d5894885ebfdbfc60a3266cddf3373d refs/tags/release-0.2.0a
+^67f323238864668e5d41ba77f17ce787cd45f0d1
+1b567a5bd4d90f9a607b82cb480fae573a3b816a refs/tags/release-0.2.1a
+^f9568de87d3c3b2e45d1e699532fb45d53791cd2
+38a36e6eaf132f2c5481280bc2d9ece14e7a1618 refs/tags/release-0.2.2a
+^9ba6374cb722455de7ed57a59111956fc9d0c5b1
+76b5505d85366bf9214de4431521095d48633009 refs/tags/release-0.2.3a
+^f9c1d0b75f62d2ac80bbff64361b93a8fef1d2af
+ba6f538b87c5d5b977f9070be08ac0d6118409c2 refs/tags/release-0.2.4a
+^6efe1890cdce366bf35289cc2017e6ae8018e981
+ca1a18b2bcc414f40a02ea439a97213f3281100d refs/tags/release-0.2.5a
+^03a9c5599c9e68a3c00f393906413dc5a4799068
+8c7ad1be40b91567b072998a070e13d9dfaef678 refs/tags/v0.3.0
+^3ae046ebe23194a5a95f9d8b44b9a29acd74d987
+ea783d31a43950d702e0def7a7174c430743b836 refs/tags/v0.4.0
+^8d73e3a8dcef405474503d30e4df93b110aeddaa
+0eba8fbcc4ea26dd773f2a805f4619cfabce0ae9 refs/tags/v0.5.0
+^0464a3563c63f8250354527cacb87e9af6bcf4d3
+ceac6eee0d7cbad7661d3465150e66197b1f404b refs/tags/v0.5.1
+^c29cb7386db91059a945373f6e4ddfd5aef4e65b
+fe23c0515da3a44ea8b4e9af304265e6746005e4 refs/tags/v0.6.0
+^c88e03436fbcaf1727819f1be8e2513289e6e1bc
+f07c605d213e31c29f73c8d428125cfd70a61058 refs/tags/v0.6.1
+^353ff576c72b420aad7ea470977f986efaca00b0
+4e603bb0ebf31324aa383a0fc7e6d590c77c46c3 refs/tags/v0.7.0
+^a0da946be9cf13d86bd88c86344fcfdaef401f15
+b3b8cca97e88428b84dc53c6c15da7310357d8f1 refs/tags/v0.7.1
+^db89f1ca754163dce9a8b13d8317210d68570558
+dd5dcc057ef7be87a83db97d03c358993621045a refs/tags/v0.7.2
+^bc5cabeb6a013a72cf19e8114e5179a311759bdc
+17652f3b8c44dbac1408e341d022b678d3c1bc13 refs/tags/v0.7.3
+^8226b30f1f51b16749990473006c1f4ffd347d19
+745fcb5672af54f8c20f7dea5529866315c97c11 refs/tags/v2.0.0
+^5b4c20eab3535d5b6f215d6e41fb4fca4f17a231
+0f35378f2a8a8ef6dac1f6c671527d6fde668a5e refs/tags/v2.0.1
+^57347e9106857de71b86ecbd93c6231544796d24
+5797f47b4e69024d02609547e14cf62ba487b60c refs/tags/v2.0.2
+^3b831a485daeb9c6a440241d62e9cc5a8fb40dc0
+91ad6fc18b9ea401d124c099602a182ceed71aa6 refs/tags/v2.1.0
+^ef297c626358a3acced74cbdf9dcaefb3bbbc5cc
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/refs/heads/2.1.x upstream/mapnik-mapnik-ef297c6/.git/refs/heads/2.1.x
--- v2.1.0/mapnik-mapnik-ef297c6/.git/refs/heads/2.1.x	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/refs/heads/2.1.x	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1 @@
+3e70226a69e32e2282e405b61d0d679fd96370aa
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/.git/refs/remotes/origin/HEAD upstream/mapnik-mapnik-ef297c6/.git/refs/remotes/origin/HEAD
--- v2.1.0/mapnik-mapnik-ef297c6/.git/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/.git/refs/remotes/origin/HEAD	2013-06-01 19:23:19.802004623 +0200
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/ctrans.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/ctrans.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/ctrans.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/ctrans.hpp	2013-06-01 19:23:20.105999268 +0200
@@ -81,6 +81,11 @@
         geom_.rewind(pos);
     }
 
+    unsigned type() const
+    {
+      return static_cast<unsigned>(geom_.type());
+    }
+
     Geometry const& geom() const
     {
         return geom_;
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/font_engine_freetype.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/font_engine_freetype.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/font_engine_freetype.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/font_engine_freetype.hpp	2013-06-01 19:23:20.109999198 +0200
@@ -333,11 +333,11 @@
         return face_set;
     }
 
-    face_set_ptr get_face_set(std::string const& name, font_set const& fset)
+    face_set_ptr get_face_set(std::string const& name, boost::optional<font_set> fset)
     {
-        if (fset.size() > 0)
+        if (fset && fset->size() > 0)
         {
-            return get_face_set(fset);
+            return get_face_set(*fset);
         }
         else
         {
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/font_set.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/font_set.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/font_set.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/font_set.hpp	2013-06-01 19:23:20.109999198 +0200
@@ -35,11 +35,11 @@
 class MAPNIK_DECL font_set
 {
 public:
-    font_set();
     font_set(std::string const& name);
     font_set(font_set const& rhs);
     font_set& operator=(font_set const& rhs);
     unsigned size() const;
+    void set_name(std::string const& name);
     std::string const& get_name() const;
     void add_face_name(std::string);
     std::vector<std::string> const& get_face_names() const;
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/geom_util.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/geom_util.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/geom_util.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/geom_util.hpp	2013-06-01 19:23:20.109999198 +0200
@@ -329,6 +329,73 @@
     return true;
 }
 
+// Compute centroid over a set of paths
+template <typename Iter>
+bool centroid_geoms(Iter start, Iter end, double & x, double & y)
+{
+  double x0 = 0.0;
+  double y0 = 0.0;
+  double x1 = 0.0;
+  double y1 = 0.0;
+  double start_x = x0;
+  double start_y = y0;
+
+  double atmp = 0.0;
+  double xtmp = 0.0;
+  double ytmp = 0.0;
+  unsigned count = 0;
+
+  while (start!=end)
+  {
+    typename Iter::value_type & path = *start++;
+    path.rewind(0);
+    unsigned command = path.vertex(&x0, &y0);
+    if (command == SEG_END) continue;
+
+    if ( ! count++ ) {
+      start_x = x0;
+      start_y = y0;
+    }
+
+    while (SEG_END != (command = path.vertex(&x1, &y1)))
+    {
+        double dx0 = x0 - start_x;
+        double dy0 = y0 - start_y;
+        double dx1 = x1 - start_x;
+        double dy1 = y1 - start_y;
+        double ai = dx0 * dy1 - dx1 * dy0;
+        atmp += ai;
+        xtmp += (dx1 + dx0) * ai;
+        ytmp += (dy1 + dy0) * ai;
+        x0 = x1;
+        y0 = y1;
+        ++count;
+    }
+
+  }
+
+  if (count == 0) return false;
+
+  if (count <= 2) {
+      x = (start_x + x0) * 0.5;
+      y = (start_y + y0) * 0.5;
+      return true;
+  }
+
+  if (atmp != 0)
+  {
+      x = (xtmp/(3*atmp)) + start_x;
+      y = (ytmp/(3*atmp)) + start_y;
+  }
+  else
+  {
+      x = x0;
+      y = y0;
+  }
+
+  return true;
+}
+
 template <typename PathType>
 bool hit_test(PathType & path, double x, double y, double tol)
 {
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/grid/grid_marker_helpers.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/grid/grid_marker_helpers.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/grid/grid_marker_helpers.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/grid/grid_marker_helpers.hpp	2013-06-01 19:23:20.113999127 +0200
@@ -78,11 +78,17 @@
     {
         marker_placement_e placement_method = sym_.get_marker_placement();
         box2d<double> bbox_(0,0, src_.width(),src_.height());
-        if (placement_method != MARKER_LINE_PLACEMENT)
+        if (placement_method != MARKER_LINE_PLACEMENT ||
+            path.type() == Point)
         {
             double x = 0;
             double y = 0;
-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
+            if (path.type() == LineString)
+            {
+                if (!label::middle_point(path, x, y))
+                    return;
+            }
+            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
             {
                 if (!label::interior_position(path, x, y))
                     return;
@@ -209,11 +215,17 @@
     void add_path(T & path)
     {
         marker_placement_e placement_method = sym_.get_marker_placement();
-        if (placement_method != MARKER_LINE_PLACEMENT)
+        if (placement_method != MARKER_LINE_PLACEMENT ||
+            path.type() == Point)
         {
             double x = 0;
             double y = 0;
-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
+            if (path.type() == LineString)
+            {
+                if (!label::middle_point(path, x, y))
+                    return;
+            }
+            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
             {
                 if (!label::interior_position(path, x, y))
                     return;
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/image_filter_types.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/image_filter_types.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/image_filter_types.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/image_filter_types.hpp	2013-06-01 19:23:20.113999127 +0200
@@ -75,7 +75,7 @@
 
 inline std::ostream& operator<< (std::ostream& os, agg_stack_blur const& filter)
 {
-    os << "agg-stack-blur:" << filter.rx << ',' << filter.ry;
+    os << "agg-stack-blur(" << filter.rx << ',' << filter.ry << ')';
     return os;
 }
 
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/json/feature_collection_grammar.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/json/feature_collection_grammar.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/json/feature_collection_grammar.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/json/feature_collection_grammar.hpp	2013-06-01 19:23:20.113999127 +0200
@@ -91,7 +91,7 @@
             > lit(']')
             ;
         
-        feature = eps[_a = construct<feature_ptr>(new_<feature_impl>(ctx_,generate_id_()))]
+        feature = eps[_a = phoenix::construct<mapnik::feature_ptr>(new_<mapnik::feature_impl>(ctx_,generate_id_()))]
             >> feature_g(*_a)[push_back(_r1,_a)]
             ;
         
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/marker_helpers.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/marker_helpers.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/marker_helpers.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/marker_helpers.hpp	2013-06-01 19:23:20.117999057 +0200
@@ -87,11 +87,17 @@
     {
         marker_placement_e placement_method = sym_.get_marker_placement();
 
-        if (placement_method != MARKER_LINE_PLACEMENT)
+        if (placement_method != MARKER_LINE_PLACEMENT ||
+            path.type() == Point)
         {
             double x = 0;
             double y = 0;
-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
+            if (path.type() == LineString)
+            {
+                if (!label::middle_point(path, x, y))
+                    return;
+            }
+            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
             {
                 if (!label::interior_position(path, x, y))
                     return;
@@ -183,11 +189,17 @@
         marker_placement_e placement_method = sym_.get_marker_placement();
         box2d<double> bbox_(0,0, src_.width(),src_.height());
 
-        if (placement_method != MARKER_LINE_PLACEMENT)
+        if (placement_method != MARKER_LINE_PLACEMENT ||
+            path.type() == Point)
         {
             double x = 0;
             double y = 0;
-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
+            if (path.type() == LineString)
+            {
+                if (!label::middle_point(path, x, y))
+                    return;
+            }
+            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
             {
                 if (!label::interior_position(path, x, y))
                     return;
@@ -398,6 +410,68 @@
     }
 }
 
+// Apply markers to a feature with multiple geometries
+template <typename Converter>
+void apply_markers_multi(feature_impl & feature, Converter& converter, markers_symbolizer const& sym)
+{
+  std::size_t geom_count = feature.paths().size();
+  if (geom_count == 1)
+  {
+      converter.apply(feature.paths()[0]);
+  }
+  else if (geom_count > 1)
+  {
+      marker_multi_policy_e multi_policy = sym.get_marker_multi_policy();
+      marker_placement_e placement = sym.get_marker_placement();
+      if (placement == MARKER_POINT_PLACEMENT &&
+           multi_policy == MARKER_WHOLE_MULTI)
+      {
+          double x, y;
+          if (label::centroid_geoms(feature.paths().begin(), feature.paths().end(), x, y))
+          {
+              geometry_type pt(Point);
+              pt.move_to(x, y);
+              // unset any clipping since we're now dealing with a point
+              converter.template unset<clip_poly_tag>();
+              converter.apply(pt);
+          }
+      }
+      else if ((placement == MARKER_POINT_PLACEMENT || placement == MARKER_INTERIOR_PLACEMENT) &&
+                multi_policy == MARKER_LARGEST_MULTI)
+      {
+          // Only apply to path with largest envelope area
+          // TODO: consider using true area for polygon types
+          double maxarea = 0;
+          geometry_type* largest = 0;
+          BOOST_FOREACH(geometry_type & geom, feature.paths())
+          {
+              const box2d<double>& env = geom.envelope();
+              double area = env.width() * env.height();
+              if (area > maxarea)
+              {
+                  maxarea = area;
+                  largest = &geom;
+              }
+          }
+          if (largest)
+          {
+              converter.apply(*largest);
+          }
+      }
+      else
+      {
+          if (multi_policy != MARKER_EACH_MULTI && placement != MARKER_POINT_PLACEMENT)
+          {
+              MAPNIK_LOG_WARN(marker_symbolizer) << "marker_multi_policy != 'each' has no effect with marker_placement != 'point'";
+          }
+          BOOST_FOREACH(geometry_type & path, feature.paths())
+          {
+            converter.apply(path);
+          }
+      }
+  }
+}
+
 }
 
 #endif //MAPNIK_MARKER_HELPERS_HPP
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/markers_symbolizer.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/markers_symbolizer.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/markers_symbolizer.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/markers_symbolizer.hpp	2013-06-01 19:23:20.117999057 +0200
@@ -46,6 +46,15 @@
 
 DEFINE_ENUM( marker_placement_e, marker_placement_enum );
 
+enum marker_multi_policy_enum {
+    MARKER_EACH_MULTI, // each component in a multi gets its marker
+    MARKER_WHOLE_MULTI, // consider all components of a multi as a whole
+    MARKER_LARGEST_MULTI, // only the largest component of a multi gets a marker
+    marker_multi_policy_enum_MAX
+};
+
+DEFINE_ENUM( marker_multi_policy_e, marker_multi_policy_enum );
+
 struct MAPNIK_DECL markers_symbolizer :
         public symbolizer_with_image, public symbolizer_base
 {
@@ -74,6 +83,8 @@
     boost::optional<stroke> get_stroke() const;
     void set_marker_placement(marker_placement_e marker_p);
     marker_placement_e get_marker_placement() const;
+    void set_marker_multi_policy(marker_multi_policy_e marker_p);
+    marker_multi_policy_e get_marker_multi_policy() const;
 private:
     expression_ptr width_;
     expression_ptr height_;
@@ -86,6 +97,7 @@
     boost::optional<float> opacity_;
     boost::optional<stroke> stroke_;
     marker_placement_e marker_p_;
+    marker_multi_policy_e marker_mp_;
 };
 
 }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/stroke.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/stroke.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/stroke.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/stroke.hpp	2013-06-01 19:23:20.121998987 +0200
@@ -33,9 +33,7 @@
 
 namespace mapnik
 {
-using std::pair;
-using std::vector;
-typedef vector<pair<double,double> > dash_array;
+typedef std::vector<std::pair<double,double> > dash_array;
 
 // if you add new tokens, don't forget to add them to the corresponding
 // string array in the cpp file.
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/text_properties.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/text_properties.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/text_properties.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/text_properties.hpp	2013-06-01 19:23:20.121998987 +0200
@@ -33,6 +33,7 @@
 #include <map>
 
 // boost
+#include <boost/optional.hpp>
 #include <boost/property_tree/ptree.hpp>
 
 namespace mapnik
@@ -58,7 +59,7 @@
     /** Write object to XML ptree. */
     void to_xml(boost::property_tree::ptree &node, bool explicit_defaults, char_properties const& dfl=char_properties()) const;
     std::string face_name;
-    font_set fontset;
+    boost::optional<font_set> fontset;
     float text_size;
     double character_spacing;
     double line_spacing; //Largest total height (fontsize+line_spacing) per line is chosen
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/text_symbolizer.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/text_symbolizer.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/text_symbolizer.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/text_symbolizer.hpp	2013-06-01 19:23:20.121998987 +0200
@@ -92,7 +92,7 @@
     void set_text_size(float size);
     std::string const& get_face_name() const func_deprecated;
     void set_face_name(std::string face_name);
-    font_set const& get_fontset() const func_deprecated;
+    boost::optional<font_set> const& get_fontset() const func_deprecated;
     void set_fontset(font_set const& fset);
     color const& get_fill() const func_deprecated;
     void set_fill(color const& fill);
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/util/conversions.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/util/conversions.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/util/conversions.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/util/conversions.hpp	2013-06-01 19:23:20.125998916 +0200
@@ -38,6 +38,7 @@
 #if BOOST_VERSION >= 104500
 #include <boost/config/warning_disable.hpp>
 #include <boost/spirit/include/karma.hpp>
+#include <boost/math/special_functions/trunc.hpp> // trunc to avoid needing C++11
 #else
 #include <boost/lexical_cast.hpp>
 #endif
@@ -67,8 +68,80 @@
 struct double_policy : boost::spirit::karma::real_policies<T>
 {
     typedef boost::spirit::karma::real_policies<T> base_type;
-    static int floatfield(T n) { return base_type::fmtflags::fixed; }
-    static unsigned precision(T n) { return 16 ;}
+
+    static int floatfield(T n) {
+      using namespace boost::spirit; // for traits
+
+      if (traits::test_zero(n))
+          return base_type::fmtflags::fixed;
+
+      T abs_n = traits::get_absolute_value(n);
+      return (abs_n >= 1e16 || abs_n < 1e-4)
+        ? base_type::fmtflags::scientific : base_type::fmtflags::fixed;
+    }
+
+    static unsigned precision(T n) {
+      if ( n == 0.0 ) return 0;
+      using namespace boost::spirit; // for traits
+      return static_cast<unsigned>(14 - boost::math::trunc(log10(traits::get_absolute_value(n))));
+    }
+
+    template <typename OutputIterator>
+    static bool dot(OutputIterator& sink, T n, unsigned precision) {
+      if (n == 0.0) return true; // avoid trailing zeroes
+      return base_type::dot(sink, n, precision);
+    }
+
+    template <typename OutputIterator>
+    static bool fraction_part (OutputIterator& sink, T n
+      , unsigned precision_, unsigned precision)
+    {
+        // NOTE: copied from karma only to avoid trailing zeroes
+        //       (maybe a bug ?)
+
+        // allow for ADL to find the correct overload for floor and log10
+        using namespace std;
+
+        using namespace boost::spirit; // for traits
+        using namespace boost::spirit::karma; // for char_inserter
+        using namespace boost; // for remove_const
+
+        if ( traits::test_zero(n) ) return true; // this part added to karma
+
+        // The following is equivalent to:
+        //    generate(sink, right_align(precision, '0')[ulong], n);
+        // but it's spelled out to avoid inter-modular dependencies.
+
+        typename remove_const<T>::type digits =
+            (traits::test_zero(n) ? 0 : floor(log10(n))) + 1;
+        bool r = true;
+        for (/**/; r && digits < precision_; digits = digits + 1)
+            r = char_inserter<>::call(sink, '0');
+        if (precision && r)
+            r = int_inserter<10>::call(sink, n);
+        return r;
+    }
+
+    template <typename CharEncoding, typename Tag, typename OutputIterator>
+    static bool exponent (OutputIterator& sink, long n)
+    {
+        // NOTE: copied from karma to force sign in exponent
+        const bool force_sign = true;
+
+        using namespace boost::spirit; // for traits
+        using namespace boost::spirit::karma; // for char_inserter, sign_inserter
+
+        long abs_n = traits::get_absolute_value(n);
+        bool r = char_inserter<CharEncoding, Tag>::call(sink, 'e') &&
+                 sign_inserter::call(sink, traits::test_zero(n)
+                    , traits::test_negative(n), force_sign);
+
+        // the C99 Standard requires at least two digits in the exponent
+        if (r && abs_n < 10)
+            r = char_inserter<CharEncoding, Tag>::call(sink, '0');
+        return r && int_inserter<10>::call(sink, abs_n);
+    }
+
 };
 
 
@@ -77,7 +150,7 @@
 inline bool to_string(std::string & str, double value)
 {
     namespace karma = boost::spirit::karma;
-    typedef boost::spirit::karma::real_generator<double, double_policy<double> > double_type;
+    typedef karma::real_generator<double, double_policy<double> > double_type;
     std::back_insert_iterator<std::string> sink(str);
     return karma::generate(sink, double_type(), value);
 }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/version.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/version.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/version.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/version.hpp	2013-06-01 19:23:20.125998916 +0200
@@ -23,13 +23,13 @@
 #ifndef MAPNIK_VERSION_HPP
 #define MAPNIK_VERSION_HPP
 
-#define MAPNIK_VERSION_IS_RELEASE 1
+#define MAPNIK_VERSION_IS_RELEASE 0
 
 #define MAPNIK_MAJOR_VERSION 2
 #define MAPNIK_MINOR_VERSION 1
-#define MAPNIK_PATCH_VERSION 0
+#define MAPNIK_PATCH_VERSION 1
 
-// translates to 200100
+// translates to 200101
 #define MAPNIK_VERSION (MAPNIK_MAJOR_VERSION*100000) + (MAPNIK_MINOR_VERSION*100) + (MAPNIK_PATCH_VERSION)
 
 #ifndef MAPNIK_STRINGIFY
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/vertex_converters.hpp upstream/mapnik-mapnik-ef297c6/include/mapnik/vertex_converters.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/include/mapnik/vertex_converters.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/include/mapnik/vertex_converters.hpp	2013-06-01 19:23:20.125998916 +0200
@@ -347,6 +347,16 @@
             disp_.vec_[index]=1;
     }
 
+    template <typename Conv>
+    void unset()
+    {
+        typedef typename boost::mpl::find<conv_types,Conv>::type iter;
+        typedef typename boost::mpl::end<conv_types>::type end;
+        std::size_t index = boost::mpl::distance<iter,end>::value - 1;
+        if (index < disp_.vec_.size())
+            disp_.vec_[index]=0;
+    }
+
 
     detail::dispatcher<args_type,conv_types> disp_;
 };
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/Makefile upstream/mapnik-mapnik-ef297c6/Makefile
--- v2.1.0/mapnik-mapnik-ef297c6/Makefile	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/Makefile	2013-06-01 19:23:19.814004411 +0200
@@ -25,7 +25,7 @@
 	@python tests/visual_tests/test.py -q || true
 	@echo "*** Running C++ tests..."
 	@for FILE in tests/cpp_tests/*-bin; do \
-		$${FILE}; \
+		$${FILE} || exit 1;\
 	done
 	@echo "*** Running python tests..."
 	@python tests/run_tests.py -q
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/postgis/connection.hpp upstream/mapnik-mapnik-ef297c6/plugins/input/postgis/connection.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/postgis/connection.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/postgis/connection.hpp	2013-06-01 19:23:20.157998352 +0200
@@ -53,7 +53,7 @@
         {
             std::ostringstream s;
             s << "Postgis Plugin: ";
-            if (conn_ )
+            if (conn_)
             {
                 std::string msg = PQerrorMessage(conn_);
                 if (! msg.empty())
@@ -64,13 +64,13 @@
                 {
                     s << "unable to connect to postgres server";
                 }
+                PQfinish(conn_);
             }
             else
             {
                 s << "unable to connect to postgres server";
             }
             s << "\n" << connection_str;
-
             throw mapnik::datasource_exception(s.str());
         }
     }
@@ -152,7 +152,7 @@
 
     bool isOK() const
     {
-        return (PQstatus(conn_) != CONNECTION_BAD);
+        return (!closed_) && (PQstatus(conn_) != CONNECTION_BAD);
     }
 
     void close()
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_datasource.cpp upstream/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_datasource.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_datasource.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_datasource.cpp	2013-06-01 19:23:20.157998352 +0200
@@ -127,11 +127,12 @@
     if (pool)
     {
         shared_ptr<Connection> conn = pool->borrowObject();
-        if (conn && conn->isOK())
-        {
-            PoolGuard<shared_ptr<Connection>,
-                shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+        if (!conn) return;
 
+        PoolGuard<shared_ptr<Connection>,
+                  shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+        if (conn->isOK())
+        {
             desc_.set_encoding(conn->client_encoding());
 
             if (geometry_table_.empty())
@@ -391,6 +392,7 @@
                     case 1042:  // bpchar
                     case 1043:  // varchar
                     case 25:    // text
+                    case 705:   // literal
                         desc_.add_descriptor(attribute_descriptor(fld_name, mapnik::String));
                         break;
                     default: // should not get here
@@ -434,6 +436,7 @@
             if (conn)
             {
                 conn->close();
+                pool->returnObject(conn);
             }
         }
     }
@@ -654,7 +657,10 @@
             s << "\"" << geometryColumn_ << "\"";
 
             if (simplify_geometries_) {
-              const double tolerance = std::min(px_gw, px_gh) / 2.0;
+              // 1/20 of pixel seems to be a good compromise to avoid
+              // drop of collapsed polygons.
+              // See https://github.com/mapnik/mapnik/issues/1639
+              const double tolerance = std::min(px_gw, px_gh) / 20.0;
               s << ", " << tolerance << ")";
             }
 
@@ -702,7 +708,17 @@
         }
         else
         {
-            throw mapnik::datasource_exception("Postgis Plugin: bad connection");
+            std::string err_msg = "Postgis Plugin:";
+            if (conn)
+            {
+                err_msg += " Bad connection";
+                pool->returnObject(conn);
+            }
+            else
+            {
+                err_msg += " Null connection";
+            }
+            throw mapnik::datasource_exception(err_msg);
         }
     }
 
@@ -725,10 +741,11 @@
     if (pool)
     {
         shared_ptr<Connection> conn = pool->borrowObject();
-        if (conn && conn->isOK())
-        {
-            PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+        if (!conn) return featureset_ptr();
+        PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
 
+        if (conn->isOK())
+        {
             if (geometryColumn_.empty())
             {
                 std::ostringstream s_error;
@@ -815,10 +832,10 @@
     if (pool)
     {
         shared_ptr<Connection> conn = pool->borrowObject();
-        if (conn && conn->isOK())
+        if (!conn) return extent_;
+        PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+        if (conn->isOK())
         {
-            PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
-
             std::ostringstream s;
 
             boost::optional<mapnik::boolean> estimate_extent =
@@ -916,10 +933,10 @@
     if (pool)
     {
         shared_ptr<Connection> conn = pool->borrowObject();
-        if (conn && conn->isOK())
+        if (!conn) return result;
+        PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
+        if (conn->isOK())
         {
-            PoolGuard<shared_ptr<Connection>, shared_ptr< Pool<Connection,ConnectionCreator> > > guard(conn, pool);
-
             std::ostringstream s;
             std::string g_type;
 
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_featureset.cpp upstream/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_featureset.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_featureset.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/postgis/postgis_featureset.cpp	2013-06-01 19:23:20.157998352 +0200
@@ -174,6 +174,7 @@
 
                     case 25:   //text
                     case 1043: //varchar
+                    case 705: //literal
                     {
                         feature->put(name, tr_->transcode(buf));
                         break;
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/build.py upstream/mapnik-mapnik-ef297c6/plugins/input/python/build.py
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/build.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/python/build.py	2013-06-01 19:23:20.157998352 +0200
@@ -14,7 +14,8 @@
 plugin_sources = Split(
   """
   %(PLUGIN_NAME)s_datasource.cpp
-  %(PLUGIN_NAME)s_featureset.cpp      
+  %(PLUGIN_NAME)s_featureset.cpp
+  %(PLUGIN_NAME)s_utils.cpp
   """ % locals()
         )
 
@@ -25,12 +26,7 @@
 # python plugin is used by a app in python using mapnik's python bindings
 # we explicitly link to libpython here so that this plugin
 # can be used from a pure C++ calling application or a different binding language
-python_link_flag = '-lpython%s' % env['PYTHON_VERSION']
-
-if env['PLATFORM'] == 'Darwin':
-    if env['PYTHON_DYNAMIC_LOOKUP']:
-        python_link_flag = '-undefined dynamic_lookup'
-    elif env['FRAMEWORK_PYTHON']:
+if env['PLATFORM'] == 'Darwin' and env['FRAMEWORK_PYTHON']:
         if env['FRAMEWORK_SEARCH_PATH']:
             python_link_flag = '-F%s -framework Python -Z' % env['FRAMEWORK_SEARCH_PATH']
         else:
@@ -41,6 +37,11 @@
                 python_link_flag = '-F/System/Library/Frameworks/ -framework Python -Z'
             else:
                 python_link_flag = '-F/ -framework Python'
+else:
+    # on linux the linkflags end up to early in the compile flags to work correctly
+    python_link_flag = ''
+    # so instead add to libraries
+    libraries.append('python%s' % env['PYTHON_VERSION'])
 
 if env['CUSTOM_LDFLAGS']:
     linkflags = '%s %s' % (env['CUSTOM_LDFLAGS'], python_link_flag)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/python_datasource.cpp upstream/mapnik-mapnik-ef297c6/plugins/input/python/python_datasource.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/python_datasource.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/python/python_datasource.cpp	2013-06-01 19:23:20.157998352 +0200
@@ -62,147 +62,170 @@
 void python_datasource::bind() const
 {
     using namespace boost;
-    using namespace boost::python;
 
     if (is_bound_) return;
 
     // if no factory callable is defined, bind is a nop
     if (factory_.empty()) return;
 
-    // split factory at ':' to parse out module and callable
-    std::vector<std::string> factory_split;
-    split(factory_split, factory_, is_any_of(":"));
-    if ((factory_split.size() < 1) || (factory_split.size() > 2))
-    {
-        // FIMXE: is this appropriate error reporting?
-        std::cerr << "python: factory string must be of the form '[module:]callable' when parsing \""
-                  << factory_ << '"' << std::endl;
-        return;
-    }
-
-    // extract the module and the callable
-    str module_name("__main__"), callable_name;
-    if (factory_split.size() == 1)
-    {
-        callable_name = str(factory_split[0]);
-    }
-    else
-    {
-        module_name = str(factory_split[0]);
-        callable_name = str(factory_split[1]);
-    }
-
+    try
     {
+        // split factory at ':' to parse out module and callable
+        std::vector<std::string> factory_split;
+        split(factory_split, factory_, is_any_of(":"));
+        if ((factory_split.size() < 1) || (factory_split.size() > 2))
+        {
+            throw mapnik::datasource_exception(
+                std::string("python: factory string must be of the form '[module:]callable' when parsing \"")
+                      + factory_ + '"');
+        }
+        // extract the module and the callable
+        boost::python::str module_name("__main__"), callable_name;
+        if (factory_split.size() == 1)
+        {
+            callable_name = boost::python::str(factory_split[0]);
+        }
+        else
+        {
+            module_name = boost::python::str(factory_split[0]);
+            callable_name = boost::python::str(factory_split[1]);
+        }
         ensure_gil lock;
-
         // import the main module from Python (in case we're embedding the
         // interpreter directly) and also import the callable.
-        object main_module = import("__main__");
-        object callable_module = import(module_name);
-        object callable = callable_module.attr(callable_name);
-
+        boost::python::object main_module = boost::python::import("__main__");
+        boost::python::object callable_module = boost::python::import(module_name);
+        boost::python::object callable = callable_module.attr(callable_name);
         // prepare the arguments
-        dict kwargs;
+        boost::python::dict kwargs;
         typedef std::map<std::string, std::string>::value_type kv_type;
         BOOST_FOREACH(const kv_type& kv, kwargs_)
         {
-            kwargs[str(kv.first)] = str(kv.second);
+            kwargs[boost::python::str(kv.first)] = boost::python::str(kv.second);
         }
 
         // get our wrapped data source
         datasource_ = callable(*boost::python::make_tuple(), **kwargs);
     }
+    catch ( boost::python::error_already_set )
+    {
+        throw mapnik::datasource_exception(extractException());
+    }
 
     is_bound_ = true;
 }
 
 mapnik::datasource::datasource_t python_datasource::type() const
 {
-    using namespace boost::python;
-
     typedef boost::optional<mapnik::datasource::geometry_t> return_type;
 
     if (!is_bound_) bind();
 
-    ensure_gil lock;
+    try
+    {
+        ensure_gil lock;
+        boost::python::object data_type = datasource_.attr("data_type");
+        long data_type_integer = boost::python::extract<long>(data_type);
+        return mapnik::datasource::datasource_t(data_type_integer);
+    }
+    catch ( boost::python::error_already_set )
+    {
+        throw mapnik::datasource_exception(extractException());
+    }
 
-    object data_type = datasource_.attr("data_type");
-    long data_type_integer = extract<long>(data_type);
-    return mapnik::datasource::datasource_t(data_type_integer);
 }
 
 mapnik::box2d<double> python_datasource::envelope() const
 {
-    using namespace boost::python;
-
     if (!is_bound_) bind();
 
-    ensure_gil lock;
-    return extract<mapnik::box2d<double> >(datasource_.attr("envelope"));
+    try
+    {
+        ensure_gil lock;
+        return boost::python::extract<mapnik::box2d<double> >(datasource_.attr("envelope"));
+    }
+    catch ( boost::python::error_already_set )
+    {
+        throw mapnik::datasource_exception(extractException());
+    }
 }
 
 boost::optional<mapnik::datasource::geometry_t> python_datasource::get_geometry_type() const
 {
-    using namespace boost::python;
-
     typedef boost::optional<mapnik::datasource::geometry_t> return_type;
 
     if (!is_bound_) bind();
 
-    ensure_gil lock;
-
-    // if the datasource object has no geometry_type attribute, return a 'none' value
-    if (!PyObject_HasAttrString(datasource_.ptr(), "geometry_type"))
-        return return_type();
-
-    object py_geometry_type = datasource_.attr("geometry_type");
-
-    // if the attribute value is 'None', return a 'none' value
-    if (py_geometry_type.ptr() == object().ptr())
-        return return_type();
-
-    long geom_type_integer = extract<long>(py_geometry_type);
-    return mapnik::datasource::geometry_t(geom_type_integer);
+    try
+    {
+        ensure_gil lock;
+        // if the datasource object has no geometry_type attribute, return a 'none' value
+        if (!PyObject_HasAttrString(datasource_.ptr(), "geometry_type"))
+        {
+            return return_type();
+        }
+        boost::python::object py_geometry_type = datasource_.attr("geometry_type");
+        // if the attribute value is 'None', return a 'none' value
+        if (py_geometry_type.ptr() == boost::python::object().ptr())
+        {
+            return return_type();
+        }
+        long geom_type_integer = boost::python::extract<long>(py_geometry_type);
+        return mapnik::datasource::geometry_t(geom_type_integer);
+    }
+    catch ( boost::python::error_already_set )
+    {
+        throw mapnik::datasource_exception(extractException());
+    }
 }
 
 mapnik::featureset_ptr python_datasource::features(mapnik::query const& q) const
 {
-    using namespace boost::python;
-
     if (!is_bound_) bind();
 
-    // if the query box intersects our world extent then query for features
-    if (envelope().intersects(q.get_bbox()))
+    try
     {
-        ensure_gil lock;
-
-        object features(datasource_.attr("features")(q));
-
-        // if 'None' was returned, return an empty feature set
-        if(features.ptr() == object().ptr())
-            return mapnik::featureset_ptr();
-
-        return boost::make_shared<python_featureset>(features);
+        // if the query box intersects our world extent then query for features
+        if (envelope().intersects(q.get_bbox()))
+        {
+            ensure_gil lock;
+            boost::python::object features(datasource_.attr("features")(q));
+            // if 'None' was returned, return an empty feature set
+            if(features.ptr() == boost::python::object().ptr())
+            {
+                return mapnik::featureset_ptr();
+            }
+            return boost::make_shared<python_featureset>(features);
+        }
+        // otherwise return an empty featureset pointer
+        return mapnik::featureset_ptr();
+    }
+    catch ( boost::python::error_already_set )
+    {
+        throw mapnik::datasource_exception(extractException());
     }
-
-    // otherwise return an empty featureset pointer
-    return mapnik::featureset_ptr();
 }
 
 mapnik::featureset_ptr python_datasource::features_at_point(mapnik::coord2d const& pt) const
 {
-    using namespace boost::python;
 
     if (!is_bound_) bind();
 
-    ensure_gil lock;
-
-    object features(datasource_.attr("features_at_point")(pt));
-
-    // if we returned none, return an empty set
-    if(features.ptr() == object().ptr())
-        return mapnik::featureset_ptr();
+    try
+    {
+        ensure_gil lock;
+        boost::python::object features(datasource_.attr("features_at_point")(pt));
+        // if we returned none, return an empty set
+        if(features.ptr() == boost::python::object().ptr())
+        {
+            return mapnik::featureset_ptr();
+        }
+        // otherwise, return a feature set which can iterate over the iterator
+        return boost::make_shared<python_featureset>(features);
+    }
+    catch ( boost::python::error_already_set )
+    {
+        throw mapnik::datasource_exception(extractException());
+    }
 
-    // otherwise, return a feature set which can iterate over the iterator
-    return boost::make_shared<python_featureset>(features);
-}
+}
\ Pas de fin de ligne  la fin du fichier
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.cpp upstream/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.cpp	2013-06-01 19:23:20.157998352 +0200
@@ -0,0 +1,23 @@
+#include "python_utils.hpp"
+
+std::string extractException()
+{
+  using namespace boost::python;
+
+  PyObject *exc,*val,*tb;
+  PyErr_Fetch(&exc,&val,&tb);
+  PyErr_NormalizeException(&exc,&val,&tb);
+  handle<> hexc(exc),hval(allow_null(val)),htb(allow_null(tb));
+  if(!hval)
+  {
+    return extract<std::string>(str(hexc));
+  }
+  else
+  {
+    object traceback(import("traceback"));
+    object format_exception(traceback.attr("format_exception"));
+    object formatted_list(format_exception(hexc,hval,htb));
+    object formatted(str("").join(formatted_list));
+    return extract<std::string>(formatted);
+  }
+}
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.hpp upstream/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.hpp
--- v2.1.0/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.hpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/plugins/input/python/python_utils.hpp	2013-06-01 19:23:20.157998352 +0200
@@ -13,4 +13,6 @@
         PyGILState_STATE gil_state_;
 };
 
+std::string extractException();
+
 #endif // PYTHON_UTILS_HPP
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/SConstruct upstream/mapnik-mapnik-ef297c6/SConstruct
--- v2.1.0/mapnik-mapnik-ef297c6/SConstruct	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/SConstruct	2013-06-01 19:23:19.814004411 +0200
@@ -350,7 +350,7 @@
 
     # Other variables
     BoolVariable('SHAPE_MEMORY_MAPPED_FILE', 'Utilize memory-mapped files in Shapefile Plugin (higher memory usage, better performance)', 'True'),
-    ('SYSTEM_FONTS','Provide location for python bindings to register fonts (if given aborts installation of bundled DejaVu fonts)',''),
+    ('SYSTEM_FONTS','Provide location for python bindings to register fonts (if provided then the bundled DejaVu fonts are not installed)',''),
     ('LIB_DIR_NAME','Name to use for the subfolder beside libmapnik where fonts and plugins are installed','mapnik'),
     PathVariable('PYTHON','Full path to Python executable used to build bindings', sys.executable),
     BoolVariable('FRAMEWORK_PYTHON', 'Link against Framework Python on Mac OS X', 'True'),
@@ -962,6 +962,7 @@
     env['PLUGINS'] = PLUGINS
     env['EXTRA_FREETYPE_LIBS'] = []
     env['SQLITE_LINKFLAGS'] = []
+    env['PYTHON_INCLUDES'] = []
     # previously a leading / was expected for LIB_DIR_NAME
     # now strip it to ensure expected behavior
     if env['LIB_DIR_NAME'].startswith(os.path.sep):
@@ -1355,7 +1356,14 @@
                 py_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print(get_python_inc())"''' % env['PYTHON']
             else:
                 py_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print get_python_inc()"''' % env['PYTHON']
-            env['PYTHON_INCLUDES'] = call(py_includes)
+            env['PYTHON_INCLUDES'].append(call(py_includes))
+
+            # also append platform specific includes
+            if py3:
+                py_plat_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print(get_python_inc(plat_specific=True))"''' % env['PYTHON']
+            else:
+                py_plat_includes = '''%s -c "from distutils.sysconfig import get_python_inc; print get_python_inc(plat_specific=True)"''' % env['PYTHON']
+            env['PYTHON_INCLUDES'].append(call(py_plat_includes))
 
             # Note: we use the plat_specific argument here to make sure to respect the arch-specific site-packages location
             if py3:
@@ -1366,7 +1374,7 @@
         else:
             env['PYTHON_SYS_PREFIX'] = os.popen('''%s -c "import sys; print sys.prefix"''' % env['PYTHON']).read().strip()
             env['PYTHON_VERSION'] = os.popen('''%s -c "import sys; print sys.version"''' % env['PYTHON']).read()[0:3]
-            env['PYTHON_INCLUDES'] = env['PYTHON_SYS_PREFIX'] + '/include/python' + env['PYTHON_VERSION']
+            env['PYTHON_INCLUDES'] = [env['PYTHON_SYS_PREFIX'] + '/include/python' + env['PYTHON_VERSION']]
             env['PYTHON_SITE_PACKAGES'] = env['DESTDIR'] + os.path.sep + env['PYTHON_SYS_PREFIX'] + os.path.sep + env['LIBDIR_SCHEMA'] + '/python' + env['PYTHON_VERSION'] + '/site-packages/'
 
         # if user-requested custom prefix fall back to manual concatenation for building subdirectories
@@ -1444,7 +1452,7 @@
         # fetch the mapnik version header in order to set the
         # ABI version used to build libmapnik.so on linux in src/build.py
         abi = conf.GetMapnikLibVersion()
-        abi_fallback = "2.1.0"
+        abi_fallback = "2.1.1-pre"
         if not abi:
             color_print(1,'Problem encountered parsing mapnik version, falling back to %s' % abi_fallback)
             abi = abi_fallback
@@ -1532,7 +1540,8 @@
             # as they are later set in the python build.py
             # ugly hack needed until we have env specific conf
             backup = env.Clone().Dictionary()
-            env.AppendUnique(CPPPATH = os.path.realpath(env['PYTHON_INCLUDES']))
+            for pyinc in env['PYTHON_INCLUDES']:
+                env.AppendUnique(CPPPATH = os.path.realpath(pyinc))
 
             if not conf.CheckHeader(header='Python.h',language='C'):
                 color_print(1,'Could not find required header files for the Python language (version %s)' % env['PYTHON_VERSION'])
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/agg/process_markers_symbolizer.cpp upstream/mapnik-mapnik-ef297c6/src/agg/process_markers_symbolizer.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/agg/process_markers_symbolizer.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/agg/process_markers_symbolizer.cpp	2013-06-01 19:23:20.193997719 +0200
@@ -26,6 +26,7 @@
 #include <mapnik/agg_rasterizer.hpp>
 
 #include <mapnik/debug.hpp>
+#include <mapnik/feature.hpp>
 #include <mapnik/geom_util.hpp>
 #include <mapnik/expression_evaluator.hpp>
 #include <mapnik/vertex_converters.hpp>
@@ -136,10 +137,7 @@
                     }
                     converter.template set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
                 else
                 {
@@ -172,10 +170,7 @@
                     }
                     converter.template set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
             }
             else // raster markers
@@ -207,11 +202,7 @@
                 }
                 converter.template set<transform_tag>(); //always transform
                 if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
-
-                BOOST_FOREACH(geometry_type & geom, feature.paths())
-                {
-                    converter.apply(geom);
-                }
+                apply_markers_multi(feature, converter, sym);
             }
         }
     }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/cairo_renderer.cpp upstream/mapnik-mapnik-ef297c6/src/cairo_renderer.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/cairo_renderer.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/cairo_renderer.cpp	2013-06-01 19:23:20.193997719 +0200
@@ -1494,11 +1494,17 @@
     {
         marker_placement_e placement_method = sym_.get_marker_placement();
 
-        if (placement_method != MARKER_LINE_PLACEMENT)
+        if (placement_method != MARKER_LINE_PLACEMENT ||
+            path.type() == Point)
         {
             double x = 0;
             double y = 0;
-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
+            if (path.type() == LineString)
+            {
+                if (!label::middle_point(path, x, y))
+                    return;
+            }
+            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
             {
                 if (!label::interior_position(path, x, y))
                     return;
@@ -1577,11 +1583,17 @@
     {
         marker_placement_e placement_method = sym_.get_marker_placement();
 
-        if (placement_method != MARKER_LINE_PLACEMENT)
+        if (placement_method != MARKER_LINE_PLACEMENT ||
+            path.type() == Point)
         {
             double x = 0;
             double y = 0;
-            if (placement_method == MARKER_INTERIOR_PLACEMENT)
+            if (path.type() == LineString)
+            {
+                if (!label::middle_point(path, x, y))
+                    return;
+            }
+            else if (placement_method == MARKER_INTERIOR_PLACEMENT)
             {
                 if (!label::interior_position(path, x, y))
                     return;
@@ -1706,10 +1718,7 @@
                     }
                     converter.set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
                 else
                 {
@@ -1734,10 +1743,7 @@
                     }
                     converter.set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
             }
             else // raster markers
@@ -1767,10 +1773,7 @@
                     }
                     converter.set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
             }
         }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/debug.cpp upstream/mapnik-mapnik-ef297c6/src/debug.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/debug.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/debug.cpp	2013-06-01 19:23:20.193997719 +0200
@@ -60,14 +60,10 @@
     #if MAPNIK_DEFAULT_LOG_SEVERITY == 0
         logger::debug
     #elif MAPNIK_DEFAULT_LOG_SEVERITY == 1
-        logger::info
-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 2
         logger::warn
-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 3
+    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 2
         logger::error
-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 4
-        logger::fatal
-    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 5
+    #elif MAPNIK_DEFAULT_LOG_SEVERITY == 3
         logger::none
     #else
         #error "Wrong default log severity level specified!"
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/font_set.cpp upstream/mapnik-mapnik-ef297c6/src/font_set.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/font_set.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/font_set.cpp	2013-06-01 19:23:20.197997648 +0200
@@ -29,8 +29,6 @@
 
 namespace mapnik
 {
-font_set::font_set()
-    : name_("") {}
 
 font_set::font_set(std::string const& name)
     : name_(name) {}
@@ -61,6 +59,11 @@
     face_names_.push_back(face_name);
 }
 
+void font_set::set_name(std::string const& name)
+{
+    name_ = name;
+}
+
 std::string const& font_set::get_name() const
 {
     return name_;
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/grid/process_markers_symbolizer.cpp upstream/mapnik-mapnik-ef297c6/src/grid/process_markers_symbolizer.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/grid/process_markers_symbolizer.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/grid/process_markers_symbolizer.cpp	2013-06-01 19:23:20.197997648 +0200
@@ -163,10 +163,7 @@
                     }
                     converter.template set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
                 else
                 {
@@ -208,10 +205,7 @@
                     }
                     converter.template set<transform_tag>(); //always transform
                     if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
-                    BOOST_FOREACH(geometry_type & geom, feature.paths())
-                    {
-                        converter.apply(geom);
-                    }
+                    apply_markers_multi(feature, converter, sym);
                 }
             }
             else // raster markers
@@ -256,10 +250,7 @@
                 }
                 converter.template set<transform_tag>(); //always transform
                 if (sym.smooth() > 0.0) converter.template set<smooth_tag>(); // optional smooth converter
-                BOOST_FOREACH(geometry_type & geom, feature.paths())
-                {
-                    converter.apply(geom);
-                }
+                apply_markers_multi(feature, converter, sym);
             }
         }
     }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/json/feature_collection_parser.cpp upstream/mapnik-mapnik-ef297c6/src/json/feature_collection_parser.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/json/feature_collection_parser.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/json/feature_collection_parser.cpp	2013-06-01 19:23:20.201997578 +0200
@@ -20,12 +20,17 @@
  *
  *****************************************************************************/
 
+// TODO https://github.com/mapnik/mapnik/issues/1658
+#include <boost/version.hpp>
+#if BOOST_VERSION >= 105200
+#define BOOST_SPIRIT_USE_PHOENIX_V3
+#endif
+
 // mapnik
 #include <mapnik/json/feature_collection_parser.hpp>
 #include <mapnik/json/feature_collection_grammar.hpp>
 
 // boost
-#include <boost/version.hpp>
 #include <boost/spirit/include/qi.hpp>
 #include <boost/spirit/include/support_multi_pass.hpp>
 
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/load_map.cpp upstream/mapnik-mapnik-ef297c6/src/load_map.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/load_map.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/load_map.cpp	2013-06-01 19:23:20.201997578 +0200
@@ -514,7 +514,7 @@
 
         // XXX Hack because map object isn't accessible by text_symbolizer
         // when it's parsed
-        fontsets_.insert(pair<std::string, font_set>(name, fontset));
+        fontsets_.insert(std::pair<std::string, font_set>(name, fontset));
     }
     catch (const config_error & ex)
     {
@@ -1027,6 +1027,10 @@
 
         marker_placement_e placement = node.get_attr<marker_placement_e>("placement",sym.get_marker_placement());
         sym.set_marker_placement(placement);
+
+        marker_multi_policy_e mpolicy = node.get_attr<marker_multi_policy_e>("multi-policy",sym.get_marker_multi_policy());
+        sym.set_marker_multi_policy(mpolicy);
+
         parse_symbolizer_base(sym, node);
         rule.append(sym);
     }
@@ -1148,7 +1152,7 @@
             placement_finder->defaults.from_xml(sym, fontsets_);
         }
         if (strict_ &&
-            !placement_finder->defaults.format.fontset.size())
+            !placement_finder->defaults.format.fontset)
         {
             ensure_font_face(placement_finder->defaults.format.face_name);
         }
@@ -1177,7 +1181,7 @@
         }
         placement_finder->defaults.from_xml(sym, fontsets_);
         if (strict_ &&
-            !placement_finder->defaults.format.fontset.size())
+            !placement_finder->defaults.format.fontset)
         {
             ensure_font_face(placement_finder->defaults.format.face_name);
         }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/map.cpp upstream/mapnik-mapnik-ef297c6/src/map.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/map.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/map.cpp	2013-06-01 19:23:20.201997578 +0200
@@ -159,6 +159,10 @@
 
 bool Map::insert_fontset(std::string const& name, font_set const& fontset)
 {
+    if (fontset.get_name() != name)
+    {
+        throw mapnik::config_error("Fontset name must match the name used to reference it on the map");
+    }
     return fontsets_.insert(make_pair(name, fontset)).second;
 }
 
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/markers_symbolizer.cpp upstream/mapnik-mapnik-ef297c6/src/markers_symbolizer.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/markers_symbolizer.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/markers_symbolizer.cpp	2013-06-01 19:23:20.201997578 +0200
@@ -37,6 +37,15 @@
 
 IMPLEMENT_ENUM( marker_placement_e, marker_placement_strings )
 
+static const char * marker_multi_policy_strings[] = {
+    "each",
+    "whole",
+    "largest",
+    ""
+};
+
+IMPLEMENT_ENUM( marker_multi_policy_e, marker_multi_policy_strings )
+
 markers_symbolizer::markers_symbolizer()
     : symbolizer_with_image(parse_path("shape://ellipse")),
       symbolizer_base(),
@@ -46,7 +55,10 @@
       allow_overlap_(false),
       spacing_(100.0),
       max_error_(0.2),
-      marker_p_(MARKER_POINT_PLACEMENT) { }
+      marker_p_(MARKER_POINT_PLACEMENT),
+      // TODO: consider defaulting to MARKER_WHOLE_MULTI,
+      //       for backward compatibility with 2.0.0
+      marker_mp_(MARKER_EACH_MULTI) { }
 
 markers_symbolizer::markers_symbolizer(path_expression_ptr const& filename)
     : symbolizer_with_image(filename),
@@ -57,7 +69,10 @@
       allow_overlap_(false),
       spacing_(100.0),
       max_error_(0.2),
-      marker_p_(MARKER_POINT_PLACEMENT) { }
+      marker_p_(MARKER_POINT_PLACEMENT),
+      // TODO: consider defaulting to MARKER_WHOLE_MULTI,
+      //       for backward compatibility with 2.0.0
+      marker_mp_(MARKER_EACH_MULTI) { }
 
 markers_symbolizer::markers_symbolizer(markers_symbolizer const& rhs)
     : symbolizer_with_image(rhs),
@@ -71,7 +86,8 @@
       fill_(rhs.fill_),
       fill_opacity_(rhs.fill_opacity_),
       stroke_(rhs.stroke_),
-      marker_p_(rhs.marker_p_) {}
+      marker_p_(rhs.marker_p_),
+      marker_mp_(rhs.marker_mp_) {}
 
 void markers_symbolizer::set_ignore_placement(bool ignore_placement)
 {
@@ -173,4 +189,14 @@
     return marker_p_;
 }
 
+void markers_symbolizer::set_marker_multi_policy(marker_multi_policy_e marker_mp)
+{
+    marker_mp_ = marker_mp;
+}
+
+marker_multi_policy_e markers_symbolizer::get_marker_multi_policy() const
+{
+    return marker_mp_;
+}
+
 }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/processed_text.cpp upstream/mapnik-mapnik-ef297c6/src/processed_text.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/processed_text.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/processed_text.cpp	2013-06-01 19:23:20.205997507 +0200
@@ -65,22 +65,22 @@
         face_set_ptr faces = font_manager_.get_face_set(p.face_name, p.fontset);
         if (faces->size() == 0)
         {
-            if (!p.fontset.get_name().empty())
+            if (p.fontset && !p.fontset->get_name().empty())
             {
-                if (p.fontset.size())
+                if (p.fontset->size())
                 {
                     if (!p.face_name.empty())
                     {
-                        throw config_error("Unable to find specified font face '" + p.face_name + "' in font set: '" + p.fontset.get_name() + "'");
+                        throw config_error("Unable to find specified font face '" + p.face_name + "' in font set: '" + p.fontset->get_name() + "'");
                     }
                     else
                     {
-                        throw config_error("No valid font face could be loaded for font set: '" + p.fontset.get_name() + "'");
+                        throw config_error("No valid font face could be loaded for font set: '" + p.fontset->get_name() + "'");
                     }
                 }
                 else
                 {
-                    throw config_error("Font set '" + p.fontset.get_name() + "' does not contain any Font face-name entries");           
+                    throw config_error("Font set '" + p.fontset->get_name() + "' does not contain any Font face-name entries");
                 }
             }
             else if (!p.face_name.empty())
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/save_map.cpp upstream/mapnik-mapnik-ef297c6/src/save_map.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/save_map.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/save_map.cpp	2013-06-01 19:23:20.205997507 +0200
@@ -98,6 +98,10 @@
         {
             set_attr( sym_node, "rasterizer", sym.get_rasterizer() );
         }
+        if ( sym.offset() != dfl.offset() || explicit_defaults_ )
+        {
+            set_attr( sym_node, "offset", sym.offset() );
+        }
         serialize_symbolizer_base(sym_node, sym);
     }
 
@@ -311,6 +315,10 @@
         {
             set_attr( sym_node, "placement", sym.get_marker_placement() );
         }
+        if ( sym.get_marker_multi_policy() != dfl.get_marker_multi_policy() || explicit_defaults_ )
+        {
+            set_attr( sym_node, "multi-policy", sym.get_marker_multi_policy() );
+        }
         if (sym.get_image_transform())
         {
             std::string tr_str = sym.get_image_transform_string();
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/text_properties.cpp upstream/mapnik-mapnik-ef297c6/src/text_properties.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/text_properties.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/text_properties.cpp	2013-06-01 19:23:20.209997437 +0200
@@ -293,11 +293,11 @@
             throw config_error("Unable to find any fontset named '" + *fontset_name_ + "'", sym);
         }
     }
-    if (!face_name.empty() && !fontset.get_name().empty())
+    if (!face_name.empty() && fontset)
     {
         throw config_error("Can't have both face-name and fontset-name", sym);
     }
-    if (face_name.empty() && fontset.get_name().empty())
+    if (face_name.empty() && !fontset)
     {
         throw config_error("Must have face-name or fontset-name", sym);
     }
@@ -305,11 +305,9 @@
 
 void char_properties::to_xml(boost::property_tree::ptree &node, bool explicit_defaults, char_properties const &dfl) const
 {
-    std::string const& fontset_name = fontset.get_name();
-    std::string const& dfl_fontset_name = dfl.fontset.get_name();
-    if (fontset_name != dfl_fontset_name || explicit_defaults)
+    if (fontset)
     {
-        set_attr(node, "fontset-name", fontset_name);
+        set_attr(node, "fontset-name", fontset->get_name());
     }
 
     if (face_name != dfl.face_name || explicit_defaults)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/text_symbolizer.cpp upstream/mapnik-mapnik-ef297c6/src/text_symbolizer.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/text_symbolizer.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/text_symbolizer.cpp	2013-06-01 19:23:20.209997437 +0200
@@ -173,7 +173,7 @@
     placement_options_->defaults.format.fontset = fontset;
 }
 
-font_set const& text_symbolizer::get_fontset() const
+boost::optional<font_set> const& text_symbolizer::get_fontset() const
 {
     return placement_options_->defaults.format.fontset;
 }
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/src/xml_tree.cpp upstream/mapnik-mapnik-ef297c6/src/xml_tree.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/src/xml_tree.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/src/xml_tree.cpp	2013-06-01 19:23:20.209997437 +0200
@@ -486,6 +486,7 @@
 compile_get_attr(filter_mode_e);
 compile_get_attr(point_placement_e);
 compile_get_attr(marker_placement_e);
+compile_get_attr(marker_multi_policy_e);
 compile_get_attr(pattern_alignment_e);
 compile_get_attr(line_rasterizer_e);
 compile_get_attr(colorizer_mode);
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/cpp_tests/conversions_test.cpp upstream/mapnik-mapnik-ef297c6/tests/cpp_tests/conversions_test.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/tests/cpp_tests/conversions_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/cpp_tests/conversions_test.cpp	2013-06-01 19:23:20.209997437 +0200
@@ -0,0 +1,133 @@
+#include <boost/version.hpp>
+#include <mapnik/util/conversions.hpp>
+#include <boost/detail/lightweight_test.hpp>
+#include <iostream>
+
+int main( int, char*[] )
+{
+    using mapnik::util::to_string;
+
+    try
+    {
+        std::string out;
+    
+        // Test double
+        to_string(out, double(0));
+        BOOST_TEST_EQ( out,  "0" );
+        out.clear();
+    
+        to_string(out, double(1));
+        BOOST_TEST_EQ( out,  "1" );
+        out.clear();
+    
+        to_string(out, double(-1));
+        BOOST_TEST_EQ( out,  "-1" );
+        out.clear();
+    
+        to_string(out, double(0.1));
+        BOOST_TEST_EQ( out,  "0.1" );
+        out.clear();
+    
+        to_string(out, double(-0.1));
+        BOOST_TEST_EQ( out,  "-0.1" );
+        out.clear();
+    
+        to_string(out, double(0.123));
+        BOOST_TEST_EQ( out,  "0.123" );
+        out.clear();
+    
+        to_string(out, double(-0.123));
+        BOOST_TEST_EQ( out,  "-0.123" );
+        out.clear();
+    
+        to_string(out, double(1e-06));
+        BOOST_TEST_EQ( out,  "1e-06" );
+        out.clear();
+    
+        to_string(out, double(-1e-06));
+        BOOST_TEST_EQ( out,  "-1e-06" );
+        out.clear();
+    
+        to_string(out, double(1e-05));
+        BOOST_TEST_EQ( out,  "1e-05" );
+        out.clear();
+    
+        to_string(out, double(-1e-05));
+        BOOST_TEST_EQ( out,  "-1e-05" );
+        out.clear();
+    
+        to_string(out, double(0.0001));
+        BOOST_TEST_EQ( out,  "0.0001" );
+        out.clear();
+    
+        to_string(out, double(-0.0001));
+        BOOST_TEST_EQ( out,  "-0.0001" );
+        out.clear();
+    
+        to_string(out, double(0.0001234567890123456));
+        // TODO: https://github.com/mapnik/mapnik/issues/1676
+        //BOOST_TEST_EQ( out,  "0.0001234567890123456" );
+        out.clear();
+    
+        to_string(out, double(-0.0001234567890123456));
+        // TODO: https://github.com/mapnik/mapnik/issues/1676
+        //BOOST_TEST_EQ( out,  "-0.0001234567890123456" );
+        out.clear();
+    
+        to_string(out, double(1000000000000000));
+        BOOST_TEST_EQ( out,  "1000000000000000" );
+        out.clear();
+    
+        to_string(out, double(-1000000000000000));
+        BOOST_TEST_EQ( out,  "-1000000000000000" );
+        out.clear();
+    
+        to_string(out, double(10000000000000.1));
+        BOOST_TEST_EQ( out,  "10000000000000.1" );
+        out.clear();
+    
+        to_string(out, double(1.00001));
+        BOOST_TEST_EQ( out,  "1.00001" );
+        out.clear();
+
+        to_string(out, double(67.65));
+        BOOST_TEST_EQ( out,  "67.65" );
+        out.clear();
+
+        to_string(out, double(67.35));
+        BOOST_TEST_EQ( out,  "67.35" );
+        out.clear();
+
+        to_string(out, double(1234000000000000));
+        BOOST_TEST_EQ( out,  "1234000000000000" );
+        out.clear();
+    
+        to_string(out, double(1.234e+16));
+        BOOST_TEST_EQ( out,  "1.234e+16" );
+        out.clear();
+    
+        to_string(out, double(-1.234e+16));
+        BOOST_TEST_EQ( out,  "-1.234e+16" );
+        out.clear();
+    
+        // Test int
+    
+        to_string(out,   int(2));
+        BOOST_TEST_EQ( out, "2" );
+        out.clear();
+    }
+    catch (std::exception const & ex)
+    {
+        std::clog << "C++ type conversions problem: " << ex.what() << "\n";
+        BOOST_TEST(false);
+    }
+
+    if (!::boost::detail::test_errors()) {
+        std::clog << "C++ type conversions: \x1b[1;32m \x1b[0m\n";
+#if BOOST_VERSION >= 104600
+        ::boost::detail::report_errors_remind().called_report_errors_function = true;
+#endif
+    } else {
+        return ::boost::report_errors();
+    }
+}
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/cpp_tests/label_algo_test.cpp upstream/mapnik-mapnik-ef297c6/tests/cpp_tests/label_algo_test.cpp
--- v2.1.0/mapnik-mapnik-ef297c6/tests/cpp_tests/label_algo_test.cpp	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/cpp_tests/label_algo_test.cpp	2013-06-01 19:23:20.209997437 +0200
@@ -31,6 +31,9 @@
     BOOST_TEST( x == 25 );
     BOOST_TEST( y == 25 );
     
+    // TODO - centroid and interior should be equal but they appear not to be (check largest)
+    // MULTIPOLYGON(((-52 40,-60 32,-68 40,-60 48,-52 40)),((-60 50,-80 30,-100 49.9999999999999,-80.0000000000001 70,-60 50)),((-52 60,-60 52,-68 60,-60 68,-52 60)))
+
     if (!::boost::detail::test_errors()) {
         std::clog << "C++ label algorithms: \x1b[1;32m \x1b[0m\n";
 #if BOOST_VERSION >= 104600
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/filter_test.py upstream/mapnik-mapnik-ef297c6/tests/python_tests/filter_test.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/filter_test.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/python_tests/filter_test.py	2013-06-01 19:23:20.393994196 +0200
@@ -20,9 +20,9 @@
 
             <![CDATA[
 
-            ([region] >= 0) 
+            ([region] >= 0)
 
-            and 
+            and
 
             ([region] <= 50)
             ]]>
@@ -49,7 +49,7 @@
     </Style>
 </Map>'''
 
-def test_filter_init():    
+def test_filter_init():
     m = mapnik.Map(1,1)
     mapnik.load_map_from_string(m,map_)
     filters = []
@@ -74,7 +74,7 @@
     0)
     and
     ([region]
-    <= 
+    <=
     50)
     '''))
 
@@ -169,13 +169,17 @@
     context = mapnik.Context()
     context.push('num')
     f = mapnik.Feature(context,0)
-    f["num"] = 1.0000
-    eq_(f["num"],1.0000)
-    expr = mapnik.Expression("[num] = 1.0000")
+    f["num1"] = 1.0000
+    f["num2"] = 1.0001
+    eq_(f["num1"],1.0000)
+    eq_(f["num2"],1.0001)
+    expr = mapnik.Expression("[num1] = 1.0000")
     eq_(expr.evaluate(f),True)
-    expr = mapnik.Expression("[num].match('.*0$')")
+    expr = mapnik.Expression("[num1].match('1')")
     eq_(expr.evaluate(f),True)
-    expr = mapnik.Expression("[num].match('.*0$')")
+    expr = mapnik.Expression("[num2] = 1.0001")
+    eq_(expr.evaluate(f),True)
+    expr = mapnik.Expression("[num2].match('1.0001')")
     eq_(expr.evaluate(f),True)
 
 def test_string_matching_on_precision():
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/geometry_io_test.py upstream/mapnik-mapnik-ef297c6/tests/python_tests/geometry_io_test.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/geometry_io_test.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/python_tests/geometry_io_test.py	2013-06-01 19:23:20.397994126 +0200
@@ -14,7 +14,7 @@
 
 wkts = [
     [1,"POINT(30 10)"],
-    [1,"POINT(30.0 10.0)"],
+    [1,"POINT(30 10)"],
     [1,"POINT(30.1 10.1)"],
     [1,"LINESTRING(30 10,10 30,40 40)"],
     [1,"POLYGON((30 10,10 20,20 40,40 40,30 10))"],
@@ -61,7 +61,7 @@
 ]
 
 geojson = [
-[1,'{"type":"Point","coordinates":[30.0,10.0]}'],
+[1,'{"type":"Point","coordinates":[30,10]}'],
 [1,'{"type":"Point","coordinates":[30.0,10.0]}'],
 [1,'{"type":"Point","coordinates":[30.1,10.1]}'],
 [1,'{"type":"LineString","coordinates":[[30.0,10.0],[10.0,30.0],[40.0,40.0]]}'],
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/object_test.py upstream/mapnik-mapnik-ef297c6/tests/python_tests/object_test.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/object_test.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/python_tests/object_test.py	2013-06-01 19:23:20.405993985 +0200
@@ -97,7 +97,7 @@
 
     # old args required method
     ts = mapnik.TextSymbolizer(mapnik.Expression('[Field_Name]'), 'Font Name', 8, mapnik.Color('black'))
-#    eq_(str(ts.name), str(mapnik2.Expression('[Field_Name]'))) name field is no longer supported
+    eq_(str(ts.name), str(mapnik.Expression('[Field_Name]'))) 
     eq_(ts.format.face_name, 'Font Name')
     eq_(ts.format.text_size, 8)
     eq_(ts.format.fill, mapnik.Color('black'))
@@ -112,7 +112,7 @@
     eq_(s.allow_overlap, False)
     eq_(s.avoid_edges, False)
     eq_(s.character_spacing,0)
-    #eq_(str(s.name), str(mapnik2.Expression('[Field Name]'))) name field is no longer supported
+    eq_(str(s.name), str(mapnik.Expression('[Field Name]')))
     eq_(s.face_name, 'DejaVu Sans Bold')
     eq_(s.allow_overlap, False)
     eq_(s.fill, mapnik.Color('#000000'))
@@ -155,7 +155,7 @@
     # 11c34b1: default transform list is empty, not identity matrix
     eq_(s.transform, '')
 
-    eq_(len(s.fontset.names), 0)
+    eq_(s.fontset, None)
 
 # ShieldSymbolizer missing image file
 # images paths are now PathExpressions are evaluated at runtime
@@ -170,11 +170,11 @@
     def check_transform(expr, expect_str=None):
         s.transform = expr
         eq_(s.transform, expr if expect_str is None else expect_str)
-    check_transform("matrix(1 2 3 4 5 6)", "matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)")
+    check_transform("matrix(1 2 3 4 5 6)", "matrix(1, 2, 3, 4, 5, 6)")
     check_transform("matrix(1, 2, 3, 4, 5, 6 +7)", "matrix(1, 2, 3, 4, 5, (6+7))")
     check_transform("rotate([a])")
     check_transform("rotate([a] -2)", "rotate(([a]-2))")
-    check_transform("rotate([a] -2 -3)", "rotate([a], -2.0, -3.0)")
+    check_transform("rotate([a] -2 -3)", "rotate([a], -2, -3)")
     check_transform("rotate([a] -2 -3 -4)", "rotate(((([a]-2)-3)-4))")
     check_transform("rotate([a] -2, 3, 4)", "rotate(([a]-2), 3, 4)")
     check_transform("translate([tx]) rotate([a])")
@@ -209,6 +209,7 @@
     eq_(p.fill_opacity,None)
     eq_(p.filename,'shape://ellipse')
     eq_(p.placement,mapnik.marker_placement.POINT_PLACEMENT)
+    eq_(p.multi_policy,mapnik.marker_multi_policy.EACH)
     eq_(p.fill,None)
     eq_(p.ignore_placement,False)
     eq_(p.spacing,100)
@@ -218,7 +219,7 @@
     eq_(p.transform,'')
     eq_(p.clip,True)
     eq_(p.comp_op,mapnik.CompositeOp.src_over)
-    
+
 
     p.width = mapnik.Expression('12')
     p.height = mapnik.Expression('12')
@@ -239,10 +240,14 @@
     p.allow_overlap = True
     p.opacity = 0.5
     p.fill_opacity = 0.5
+    p.placement = mapnik.marker_placement.LINE_PLACEMENT
+    p.multi_policy = mapnik.marker_multi_policy.WHOLE
 
     eq_(p.allow_overlap, True)
     eq_(p.opacity, 0.5)
     eq_(p.fill_opacity, 0.5)
+    eq_(p.multi_policy,mapnik.marker_multi_policy.WHOLE)
+    eq_(p.placement,mapnik.marker_placement.LINE_PLACEMENT)
 
     #https://github.com/mapnik/mapnik/issues/1285
     #https://github.com/mapnik/mapnik/issues/1427
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/query_test.py upstream/mapnik-mapnik-ef297c6/tests/python_tests/query_test.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/query_test.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/python_tests/query_test.py	2013-06-01 19:23:20.405993985 +0200
@@ -17,6 +17,10 @@
     r = query.resolution
     assert_almost_equal(r[0], 1.0, places=7)
     assert_almost_equal(r[1], 1.0, places=7)
+    # https://github.com/mapnik/mapnik/issues/1762
+    eq_(query.property_names,[])
+    query.add_property_name('migurski')
+    eq_(query.property_names,['migurski'])
 
 # Converting *from* tuples *to* resolutions is not yet supported
 @raises(TypeError)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/test_fontset.py upstream/mapnik-mapnik-ef297c6/tests/python_tests/test_fontset.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/python_tests/test_fontset.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/python_tests/test_fontset.py	2013-06-01 19:23:20.405993985 +0200
@@ -17,6 +17,25 @@
     eq_(len(fs.names),2)
     eq_(list(fs.names),['DejaVu Sans Book','DejaVu Sans Oblique'])
 
+def test_loading_fontset_from_python():
+    m = mapnik.Map(256,256)
+    fset = mapnik.FontSet('foo')
+    fset.add_face_name('Comic Sans')
+    fset.add_face_name('Papyrus')
+    eq_(fset.name,'foo')
+    fset.name = 'my-set'
+    eq_(fset.name,'my-set')
+    m.append_fontset('my-set', fset)
+    sty = mapnik.Style()
+    rule = mapnik.Rule()
+    tsym = mapnik.TextSymbolizer()
+    eq_(tsym.fontset,None)
+    tsym.fontset = fset
+    rule.symbols.append(tsym)
+    sty.rules.append(rule)
+    m.append_style('Style',sty)
+    serialized_map = mapnik.save_map_to_string(m)
+    eq_('fontset-name="my-set"' in serialized_map,True)
 
 if __name__ == "__main__":
     setup()
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/run_tests.py upstream/mapnik-mapnik-ef297c6/tests/run_tests.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/run_tests.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/run_tests.py	2013-06-01 19:23:20.405993985 +0200
@@ -5,7 +5,7 @@
 try:
     import nose
 except ImportError:
-    sys.stderr.write("Unable to run python tests: the third party 'nose' module is required\nTo install 'nose' do:\n\tsudo pip install nose (or on debian systems: apt-get install python-nose\n")
+    sys.stderr.write("Unable to run python tests: the third party 'nose' module is required\nTo install 'nose' do:\n\tsudo pip install nose (or on debian systems: apt-get install python-nose)\n")
     sys.exit(1)
     
 from python_tests.utilities import TodoPlugin
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-multi-policy.csv upstream/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-multi-policy.csv
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-multi-policy.csv	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-multi-policy.csv	2013-06-01 19:23:20.409993914 +0200
@@ -0,0 +1,3 @@
+i|wkt
+1|MULTIPOLYGON(((90 40,50 0,10 40,50 80,90 40)),((190 40,150 0,110 40,150 80,190 40)),((190 140,150 100,110 140,150 180,190 140)))
+2|MULTIPOLYGON(((48 130,40 122,32 130,40 138,48 130)),((40 140,20 120,0 140,20 160,40 140)),((48 150,40 142,32 150,40 158,48 150)))
\ Pas de fin de ligne  la fin du fichier
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-on-line.csv upstream/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-on-line.csv
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-on-line.csv	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/data/marker-on-line.csv	2013-06-01 19:23:20.409993914 +0200
@@ -0,0 +1,2 @@
+i|wkt
+1|LINESTRING(-10  0, 0 20, 10 0, 15 5)
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/data/whole-centroid.csv upstream/mapnik-mapnik-ef297c6/tests/visual_tests/data/whole-centroid.csv
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/data/whole-centroid.csv	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/data/whole-centroid.csv	2013-06-01 19:23:20.409993914 +0200
@@ -0,0 +1,2 @@
+i|wkt
+1|MULTIPOLYGON(((1350057.96009438 5942345.52058283,1384876.13646624 5891754.2133652,1527153.68896859 5865144.36766544,1489794.86785838 5828107.21457916,1521644.71000822 5808839.16705438,1500586.73589334 5782129.46376012,1549474.58270654 5722446.94649062,1526963.22131985 5715859.64352432,1468675.11142609 5744853.11521536,1367157.74707515 5695509.5055605,1353768.57268098 5663160.88833932,1395853.46277285 5615400.34143299,1363168.83576153 5576894.81504537,1376836.42020216 5503694.0028362,1516356.92287605 5396662.575031,1560328.12173938 5261876.31080913,1640818.23615492 5173802.74601002,1796912.65253506 5148129.98779792,1773597.67574436 5083111.70893878,2005049.37613903 4960037.26198969,2060770.68121407 4885821.98463312,2042650.53978071 4835753.32622244,1988073.15379307 4907241.27057499,1882814.34135654 4930901.063827,1835287.04135981 4832212.44229475,1909252.60910046 4777690.54700568,1911262.92778469 4716420.6995481,1847346.61575592 4693181.77244718,1788068.875589 4568718.26175616,1740109.09937055 4581073.81722757,1805880.43939388 4708906.48580766,1744005.2815483 4870423.42300908,1235522.56053157 5220039.63151647,1125161.53055404 5466602.89896275,973921.757167397 5532097.82173426,838019.24926376 5432786.3871293,852954.651385017 5491916.6901273,776607.959736312 5509523.04321204,782761.478548388 5595015.13624148,736908.312373676 5638877.1573602,793460.506128018 5662194.42680345,756857.878318762 5745270.82868898,783472.587455564 5769448.93739922,874497.199243332 5767386.72200479,939134.416294499 5854912.10535634,1005956.9462694 5754390.71173147,1033261.27965169 5860165.00562569,1127666.33041638 5816836.29071798,1118791.82929085 5867309.80784728,1164989.30665057 5868344.65660203,1165652.54817671 5921100.82966656,1350057.96009438 5942345.52058283),(1386948.01482887 5449379.17151171,1392606.60718488 5463421.03119553,1382120.31115215 5458937.77184712,1386948.01482887 5449379.17151171),(1385381.11851082 5146477.94829492,1386669.06721543 5146224.9584086,1386111.70929647 5147206.59661607,1385381.11851082 5146477.94829492)),((1382897.20987839 5687974.04417046,1371857.98993491 5675822.90372079,1377393.1289756 5689163.60754804,1382897.20987839 5687974.04417046)),((1095847.54640445 5317215.2838641,1091704.01231816 5313451.44710224,1091394.65545324 5321701.46563701,1094455.94145006 5323479.01597989,1095847.54640445 5317215.2838641)),((1162299.15983606 5288324.53042776,1160289.06379081 5267765.62824438,1124543.26210218 5277407.73480368,1162299.15983606 5288324.53042776)),((1123028.09251298 5247084.38946664,1122316.87228631 5254141.60947014,1124512.20396424 5250317.54284925,1123028.09251298 5247084.38946664)),((1215144.97114443 5209828.83212963,1209640.77892215 5214848.8689761,1210908.5966028 5219286.46510058,1215144.97114443 5209828.83212963)),((1148446.00580429 5208658.24432317,1145817.64130717 5213552.48912728,1149497.41839483 5212548.16532901,1148446.00580429 5208658.24432317)),((1059019.27398736 5033998.10699295,1093806.61486026 4942691.99568292,1065234.68643633 4743259.71214946,1003916.12604469 4759901.51823648,986197.736653606 4704377.88889769,935856.725207561 4715744.68629496,952523.590688621 4846503.91226084,911984.817004403 4999606.76073705,1059019.27398736 5033998.10699295)),((928311.824080081 5021563.59386512,914520.452365687 5011234.44611049,926301.728034833 5030262.29618597,928311.824080081 5021563.59386512)),((1443164.46899898 4995230.22633471,1441618.24127186 5000220.31310592,1445823.55767554 5002226.81825718,1443164.46899898 4995230.22633471)),((1553061.29669992 4968395.29665014,1542207.75766705 4973291.02362767,1552690.38015659 4974433.31609162,1553061.29669992 4968395.29665014)),((1581911.63517033 4947738.11891254, 1587632.34380218 4947004.77788114,1580427.52371907 4944237.33055168,1581911.63517033 4947738.11891254)),((923085.819265294 4735088.56864719,915479.024500905 4745293.69583645,924260.796490606 4748923.38178062,923085.819265294 4735088.56864719)),((1693571.31832746 4688858.4894456,1690973.90064878 4691713.90965507,1696416.19923417 4693935.9965921,1693571.31832746 4688858.4894456)),((1466448.61029075 4677403.01590106,1465211.85074803 4680849.56314581,1469231.59756058 4680414.29421003,1466448.61029075 4677403.01590106)),((1655135.14718535 4654767.34922581,1646940.91946804 4659946.37928978,1655166.09400377 4661409.67928983,1655135.14718535 4654767.34922581)),((1664813.70899286 4642559.56041499,1660020.95963625 4652672.28390196,1665772.39244759 4652790.51476716,1664813.70899286 4642559.56041499)),((1668555.37971741 4630998.75869634,1663236.86840579 4636007.55629286,1665215.68367412 4640507.06235257,1668555.37971741 4630998.75869634)),((1728668.01606527 4598788.94471507,1679439.97688818 4506146.77040914,1705043.45977066 4440345.73224938,1678852.4326158 4390316.66779138,1382835.42756099 4550662.053593,1482404.47818411 4610314.59733156,1532745.60094962 4575266.49172867,1728668.01606527 4598788.94471507)),((1344059.17537453 4572873.96816367,1339173.36292359 4577580.75464391,1342420.21851156 4577895.44505675,1344059.17537453 4572873.96816367)),((1375259.46829558 4566170.07673534,1366044.55216722 4570443.18173048,1373589.78725316 4570168.66006012,1375259.46829558 4566170.07673534)),((1337596.41101701 4402695.43852239,1328134.14298011 4415398.45409661,1341214.18314831 4410841.06668909,1337596.41101701 4402695.43852239)))
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/images/marker_line_placement_on_points-500-reference.png et upstream/mapnik-mapnik-ef297c6/tests/visual_tests/images/marker_line_placement_on_points-500-reference.png sont diffrents
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/images/marker-multi-policy-600-reference.png et upstream/mapnik-mapnik-ef297c6/tests/visual_tests/images/marker-multi-policy-600-reference.png sont diffrents
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/images/marker-on-line-600-reference.png et upstream/mapnik-mapnik-ef297c6/tests/visual_tests/images/marker-on-line-600-reference.png sont diffrents
Les fichiers binaires v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/images/whole-centroid-600-reference.png et upstream/mapnik-mapnik-ef297c6/tests/visual_tests/images/whole-centroid-600-reference.png sont diffrents
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker_line_placement_on_points.xml upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker_line_placement_on_points.xml
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker_line_placement_on_points.xml	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker_line_placement_on_points.xml	2013-06-01 19:23:20.417993774 +0200
@@ -0,0 +1,36 @@
+<!DOCTYPE Map>
+<Map background-color="white" srs="+init=epsg:4326" minimum-version="0.7.2">
+
+    <Style name="1">
+        <Rule>
+          <Filter>[id]=1</Filter>
+          <MarkersSymbolizer fill="darkgreen" opacity=".7" width="15" height="10" stroke="green" stroke-width="7" stroke-opacity=".2" placement="line" marker-type="ellipse"/>
+        </Rule>
+        <Rule>
+          <Filter>[id]=2</Filter>
+             <MarkersSymbolizer fill="darkorange" opacity=".7" width="20" height="10" stroke="orange" stroke-width="7" stroke-opacity=".2" placement="line" marker-type="ellipse"/>
+        </Rule>
+        <Rule>
+          <Filter>[id]=3</Filter>
+             <MarkersSymbolizer fill="darkred" opacity=".7" width="20" height="10" stroke="orange" stroke-width="7" stroke-opacity=".2" placement="line" marker-type="ellipse"/>
+        </Rule>
+    </Style>
+    <Layer name="point" srs="+init=epsg:4326">
+        <StyleName>1</StyleName>
+        <Datasource>
+            <Parameter name="type">csv</Parameter>
+            <Parameter name="inline">
+            x,y,id
+            0,0,1
+            5,0,1
+            5,5,1
+            0,5,1
+            2.5,2.5,2
+            2.5,3,3
+            2.5,2,3
+            3,2.5,3
+            2,2.5,3
+            </Parameter>
+        </Datasource>
+    </Layer>
+</Map>
\ Pas de fin de ligne  la fin du fichier
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-multi-policy.xml upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-multi-policy.xml
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-multi-policy.xml	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-multi-policy.xml	2013-06-01 19:23:20.417993774 +0200
@@ -0,0 +1,36 @@
+<Map maximum-extent="0,0,190,180">
+<Style name="each">
+  <Rule>
+    <Filter>[i] = 1</Filter>
+    <MarkersSymbolizer placement="point" fill="red" width="30" allow-overlap="true"/>
+  </Rule>
+</Style>
+<Style name="whole">
+  <Rule>
+    <Filter>[i] = 1</Filter>
+    <MarkersSymbolizer placement="point" multi-policy="whole" fill="yellow" width="20" allow-overlap="true"/>
+  </Rule>
+</Style>
+<Style name="largest">
+  <Rule>
+    <Filter>[i] = 2</Filter>
+    <MarkersSymbolizer placement="point" multi-policy="largest" fill="blue" width="10" allow-overlap="true"/>
+  </Rule>
+</Style>
+<Style name="boundary">
+  <Rule>
+    <LineSymbolizer />
+  </Rule>
+</Style>
+<Layer name="multi">
+    <StyleName>boundary</StyleName>
+    <StyleName>each</StyleName>
+    <StyleName>whole</StyleName>
+    <StyleName>largest</StyleName>
+    <Datasource>
+       <Parameter name="type">csv</Parameter>
+       <Parameter name="file">../data/marker-multi-policy.csv</Parameter>
+       <Parameter name="separator">|</Parameter>
+    </Datasource>
+  </Layer>
+</Map>
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-on-line.xml upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-on-line.xml
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-on-line.xml	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/marker-on-line.xml	2013-06-01 19:23:20.417993774 +0200
@@ -0,0 +1,21 @@
+<Map>
+<Style name="line" filter-mode="first" >
+  <Rule>
+    <LineSymbolizer stroke="#000000" />
+  </Rule>
+</Style>
+<Style name="point-placement" filter-mode="first" >
+  <Rule>
+    <MarkersSymbolizer placement="point" marker-type="ellipse" fill="blue" />
+  </Rule>
+</Style>
+<Layer name="carto_tests">
+    <StyleName>line</StyleName>
+    <StyleName>point-placement</StyleName>
+    <Datasource>
+       <Parameter name="type">csv</Parameter>
+       <Parameter name="file">../data/marker-on-line.csv</Parameter>
+       <Parameter name="separator">|</Parameter>
+    </Datasource>
+  </Layer>
+</Map>
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/whole-centroid.xml upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/whole-centroid.xml
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/styles/whole-centroid.xml	1970-01-01 01:00:00.000000000 +0100
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/styles/whole-centroid.xml	2013-06-01 19:23:20.421993703 +0200
@@ -0,0 +1,21 @@
+<Map maximum-extent="736908, 4390316, 2060771, 5942346">
+<Style name="whole">
+  <Rule>
+    <MarkersSymbolizer placement="point" multi-policy="whole" fill="yellow" width="20" allow-overlap="true"/>
+  </Rule>
+</Style>
+<Style name="boundary">
+  <Rule>
+    <LineSymbolizer />
+  </Rule>
+</Style>
+<Layer name="multi">
+    <StyleName>boundary</StyleName>
+    <StyleName>whole</StyleName>
+    <Datasource>
+       <Parameter name="type">csv</Parameter>
+       <Parameter name="file">../data/whole-centroid.csv</Parameter>
+       <Parameter name="separator">|</Parameter>
+    </Datasource>
+  </Layer>
+</Map>
diff -Nur v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/test.py upstream/mapnik-mapnik-ef297c6/tests/visual_tests/test.py
--- v2.1.0/mapnik-mapnik-ef297c6/tests/visual_tests/test.py	2012-08-23 23:52:53.000000000 +0200
+++ upstream/mapnik-mapnik-ef297c6/tests/visual_tests/test.py	2013-06-01 19:23:20.421993703 +0200
@@ -27,6 +27,14 @@
     {'name': "lines-2", 'sizes': sizes_few_square},
     {'name': "lines-3", 'sizes': sizes_few_square},
     {'name': "lines-shield", 'sizes': sizes_few_square},
+    {'name': "marker-multi-policy", 'sizes':[(600,400)],
+        'bbox': mapnik.Box2d(0, 0, 190, 180)},
+    {'name': "marker-on-line", 'sizes':[(600,400)],
+        'bbox': mapnik.Box2d(-10, 0, 15, 20)},
+    {'name': "marker_line_placement_on_points", 'sizes':[(500,100)],
+        'bbox': mapnik.Box2d(0, 0, 5, 5)},
+    {'name': "whole-centroid", 'sizes':[(600,400)],
+        'bbox': mapnik.Box2d(736908, 4390316, 2060771, 5942346)},
     {'name': "simple-E"},
     {'name': "simple-NE"},
     {'name': "simple-NW"},
